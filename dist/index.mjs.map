{"version":3,"sources":["../lib/server.ts","../lib/types.ts","../lib/storage.ts","../lib/utils.ts","../lib/chain.ts","../lib/providers/solana.ts","../lib/webhook.ts","../lib/qrcode.ts","../lib/subscription.ts","../lib/referral.ts","../lib/installment.ts","../lib/paylink-token.ts"],"sourcesContent":["import express, { Express, Request, Response, NextFunction } from 'express';\nimport cors from 'cors';\nimport helmet from 'helmet';\nimport type {\n  PaylinkConfig,\n  PayLink,\n  Payment,\n  CreatePayLinkInput,\n  Protocol402Response,\n  Protocol403Response,\n  Storage,\n  ChainConfig,\n  Subscription,\n  CreateSubscriptionInput,\n  PaymentOption,\n  Referral,\n  ReferralCommission,\n  CreateReferralInput,\n  InstallmentPlan,\n  InstallmentPayment,\n  CreateInstallmentPlanInput,\n} from './types.js';\nimport { ReasonCode, SOLANA_CHAIN_IDS } from './types.js';\nimport { MemoryStorage } from './storage.js';\nimport { ChainVerifier, MockVerifier } from './chain.js';\nimport { SolanaVerifier, MockSolanaVerifier } from './providers/solana.js';\nimport { WebhookManager } from './webhook.js';\nimport { generatePaymentQR, generateQRCodeSVG, type PaymentQRData } from './qrcode.js';\nimport {\n  generateId,\n  generateUUID,\n  generateNonce,\n  sign,\n  isExpired,\n  isLimitReached,\n  REASON_MESSAGES,\n} from './utils.js';\nimport {\n  SubscriptionManager,\n  isPaymentDue,\n  isInTrialPeriod,\n  getIntervalDisplayName,\n} from './subscription.js';\nimport {\n  ReferralManager,\n  buildReferralUrl,\n  parseReferralCode,\n} from './referral.js';\nimport {\n  InstallmentManager,\n  calculateInstallmentAmounts,\n  getInstallmentProgress,\n  formatInstallmentSchedule,\n} from './installment.js';\n\ntype Verifier = ChainVerifier | MockVerifier | SolanaVerifier | MockSolanaVerifier;\n\n/**\n * Paylink Server\n * Self-hosted paid links with blockchain payment verification\n */\nexport class PaylinkServer {\n  private app: Express;\n  private config: Required<Omit<PaylinkConfig, 'chains' | 'webhook' | 'paylinkToken'>> & { \n    chains: PaylinkConfig['chains'];\n    webhook?: PaylinkConfig['webhook'];\n    paylinkToken?: PaylinkConfig['paylinkToken'];\n  };\n  private storage: Storage;\n  private verifiers: Map<number, Verifier>;\n  private webhookManager?: WebhookManager;\n  private subscriptionManager: SubscriptionManager;\n  private referralManager: ReferralManager;\n  private installmentManager: InstallmentManager;\n  private subscriptionCheckInterval?: NodeJS.Timeout;\n  private installmentCheckInterval?: NodeJS.Timeout;\n\n  constructor(config: PaylinkConfig) {\n    // Default config\n    this.config = {\n      port: config.port ?? 3000,\n      baseUrl: config.baseUrl ?? '',\n      basePath: config.basePath ?? '/pay',\n      chains: config.chains,\n      paymentTimeout: config.paymentTimeout ?? 900,\n      signatureSecret: config.signatureSecret ?? '',\n      apiKey: config.apiKey ?? '',\n      cors: config.cors ?? true,\n      webhook: config.webhook,\n      paylinkToken: config.paylinkToken,\n    };\n\n    this.storage = new MemoryStorage();\n    this.verifiers = new Map();\n    this.subscriptionManager = new SubscriptionManager(this.storage);\n    this.referralManager = new ReferralManager(this.storage);\n    this.installmentManager = new InstallmentManager(this.storage);\n\n    // Initialize webhook manager\n    if (config.webhook?.url) {\n      this.webhookManager = new WebhookManager(config.webhook);\n    }\n\n    // Initialize chain verifiers\n    for (const chain of config.chains) {\n      this.verifiers.set(chain.chainId, this.createVerifier(chain));\n    }\n\n    this.app = express();\n    this.setupMiddleware();\n    this.setupRoutes();\n  }\n\n  /**\n   * Create appropriate verifier based on chain type\n   */\n  private createVerifier(chain: ChainConfig): Verifier {\n    const isSolana = chain.type === 'solana' || this.isSolanaChainId(chain.chainId);\n    \n    if (chain.rpcUrl === 'mock') {\n      return isSolana ? new MockSolanaVerifier() : new MockVerifier();\n    }\n    \n    if (isSolana) {\n      return new SolanaVerifier({\n        rpcUrl: chain.rpcUrl,\n        confirmations: chain.confirmations,\n      });\n    }\n    \n    return new ChainVerifier(chain);\n  }\n\n  /**\n   * Check if chain ID is a Solana chain\n   */\n  private isSolanaChainId(chainId: number): boolean {\n    return chainId === SOLANA_CHAIN_IDS.MAINNET ||\n           chainId === SOLANA_CHAIN_IDS.DEVNET ||\n           chainId === SOLANA_CHAIN_IDS.TESTNET;\n  }\n\n  /**\n   * Get Express app instance\n   */\n  getApp(): Express {\n    return this.app;\n  }\n\n  /**\n   * Get storage instance\n   */\n  getStorage(): Storage {\n    return this.storage;\n  }\n\n  /**\n   * Set custom storage\n   */\n  setStorage(storage: Storage): void {\n    this.storage = storage;\n    this.subscriptionManager = new SubscriptionManager(storage);\n    this.referralManager = new ReferralManager(storage);\n    this.installmentManager = new InstallmentManager(storage);\n  }\n\n  /**\n   * Get subscription manager\n   */\n  getSubscriptionManager(): SubscriptionManager {\n    return this.subscriptionManager;\n  }\n\n  /**\n   * Get referral manager\n   */\n  getReferralManager(): ReferralManager {\n    return this.referralManager;\n  }\n\n  /**\n   * Get installment manager\n   */\n  getInstallmentManager(): InstallmentManager {\n    return this.installmentManager;\n  }\n\n  /**\n   * Start server\n   */\n  start(): void {\n    // Start subscription payment check\n    this.startSubscriptionCheck();\n    // Start installment payment check\n    this.startInstallmentCheck();\n\n    this.app.listen(this.config.port, () => {\n      console.log('');\n      console.log('╔══════════════════════════════════════════════════════════╗');\n      console.log('║              Paylink Protocol Server v1.7.0              ║');\n      console.log('╠══════════════════════════════════════════════════════════╣');\n      console.log(`║  Port:     ${String(this.config.port).padEnd(44)}║`);\n      console.log(`║  Base URL: ${(this.config.baseUrl || 'http://localhost:' + this.config.port).padEnd(44)}║`);\n      console.log(`║  Chains:   ${this.config.chains.map(c => c.name).join(', ').padEnd(44)}║`);\n      if (this.webhookManager) {\n        console.log(`║  Webhook:  ${this.config.webhook?.url?.substring(0, 44).padEnd(44)}║`);\n      }\n      console.log('╚══════════════════════════════════════════════════════════╝');\n      console.log('');\n      console.log('Endpoints:');\n      console.log(`  GET  ${this.config.basePath}/:id          → Payment page (402/403/302)`);\n      console.log(`  GET  ${this.config.basePath}/:id/status   → Check payment status`);\n      console.log(`  POST ${this.config.basePath}/:id/confirm  → Confirm with txHash`);\n      console.log(`  GET  ${this.config.basePath}/:id/qr       → QR code for payment`);\n      console.log('');\n      if (this.config.apiKey) {\n        console.log('Admin API (X-API-Key header required):');\n        console.log('  POST   /api/links       → Create link');\n        console.log('  GET    /api/links       → List links');\n        console.log('  GET    /api/links/:id   → Get link');\n        console.log('  DELETE /api/links/:id   → Disable link');\n        console.log('  GET    /api/payments    → List payments');\n        console.log('');\n      }\n    });\n  }\n\n  // ========================================\n  // PAYLINK METHODS\n  // ========================================\n\n  /**\n   * Create a new payment link\n   */\n  async createPayLink(input: CreatePayLinkInput): Promise<PayLink> {\n    const now = new Date();\n    \n    const payLink: PayLink = {\n      id: generateId(),\n      targetUrl: input.targetUrl,\n      price: input.price,\n      paymentOptions: input.paymentOptions,\n      recipientAddress: input.recipientAddress,\n      status: 'active',\n      createdAt: now,\n      updatedAt: now,\n      description: input.description,\n      maxUses: input.maxUses,\n      usedCount: 0,\n      expiresAt: input.expiresAt,\n      metadata: input.metadata,\n      subscription: input.subscription,\n      multiUse: input.multiUse,\n      referral: input.referral,\n    };\n\n    await this.storage.savePayLink(payLink);\n\n    // Send webhook notification\n    if (this.webhookManager) {\n      this.webhookManager.sendLinkEvent('link.created', payLink).catch(err => {\n        console.error('Webhook error:', err);\n      });\n    }\n\n    return payLink;\n  }\n\n  /**\n   * Get payment link by ID\n   */\n  async getPayLink(id: string): Promise<PayLink | null> {\n    return this.storage.getPayLink(id);\n  }\n\n  /**\n   * Disable a payment link\n   */\n  async disablePayLink(id: string): Promise<void> {\n    const link = await this.storage.getPayLink(id);\n    if (!link) throw new Error('Link not found');\n    \n    link.status = 'disabled';\n    await this.storage.updatePayLink(link);\n\n    // Send webhook notification\n    if (this.webhookManager) {\n      this.webhookManager.sendLinkEvent('link.disabled', link).catch(err => {\n        console.error('Webhook error:', err);\n      });\n    }\n  }\n\n  // ========================================\n  // SUBSCRIPTION METHODS\n  // ========================================\n\n  /**\n   * Create a subscription for a subscriber\n   */\n  async createSubscription(\n    payLinkId: string,\n    subscriberAddress: string,\n    metadata?: Record<string, unknown>\n  ): Promise<Subscription> {\n    const link = await this.storage.getPayLink(payLinkId);\n    if (!link) throw new Error('PayLink not found');\n    if (!link.subscription) throw new Error('PayLink is not a subscription link');\n\n    const subscription = await this.subscriptionManager.createSubscription(link, {\n      payLinkId,\n      subscriberAddress,\n      metadata,\n    });\n\n    // Send webhook\n    if (this.webhookManager) {\n      this.webhookManager.sendSubscriptionEvent('subscription.created', subscription, link).catch(err => {\n        console.error('Webhook error:', err);\n      });\n    }\n\n    return subscription;\n  }\n\n  /**\n   * Cancel a subscription\n   */\n  async cancelSubscription(subscriptionId: string): Promise<Subscription> {\n    const subscription = await this.subscriptionManager.cancelSubscription(subscriptionId);\n    const link = await this.storage.getPayLink(subscription.payLinkId);\n\n    if (this.webhookManager && link) {\n      this.webhookManager.sendSubscriptionEvent('subscription.cancelled', subscription, link).catch(err => {\n        console.error('Webhook error:', err);\n      });\n    }\n\n    return subscription;\n  }\n\n  /**\n   * Pause a subscription\n   */\n  async pauseSubscription(subscriptionId: string): Promise<Subscription> {\n    const subscription = await this.subscriptionManager.pauseSubscription(subscriptionId);\n    const link = await this.storage.getPayLink(subscription.payLinkId);\n\n    if (this.webhookManager && link) {\n      this.webhookManager.sendSubscriptionEvent('subscription.paused', subscription, link).catch(err => {\n        console.error('Webhook error:', err);\n      });\n    }\n\n    return subscription;\n  }\n\n  /**\n   * Resume a subscription\n   */\n  async resumeSubscription(subscriptionId: string): Promise<Subscription> {\n    const subscription = await this.subscriptionManager.resumeSubscription(subscriptionId);\n    const link = await this.storage.getPayLink(subscription.payLinkId);\n\n    if (this.webhookManager && link) {\n      this.webhookManager.sendSubscriptionEvent('subscription.resumed', subscription, link).catch(err => {\n        console.error('Webhook error:', err);\n      });\n    }\n\n    return subscription;\n  }\n\n  /**\n   * Get subscription by ID\n   */\n  async getSubscription(id: string): Promise<Subscription | null> {\n    return this.subscriptionManager.getSubscription(id);\n  }\n\n  /**\n   * Start periodic subscription check\n   */\n  private startSubscriptionCheck(): void {\n    // Check every minute\n    this.subscriptionCheckInterval = setInterval(async () => {\n      try {\n        const dueSubscriptions = await this.subscriptionManager.getDueSubscriptions();\n        \n        for (const sub of dueSubscriptions) {\n          const link = await this.storage.getPayLink(sub.payLinkId);\n          if (!link) continue;\n\n          const gracePeriodHours = link.subscription?.gracePeriodHours ?? 24;\n          const graceEnd = new Date(sub.nextPaymentDue);\n          graceEnd.setHours(graceEnd.getHours() + gracePeriodHours);\n\n          const now = new Date();\n\n          // Check if past grace period\n          if (now > graceEnd && sub.status === 'active') {\n            await this.subscriptionManager.markPastDue(sub.id);\n            \n            if (this.webhookManager) {\n              const updated = await this.subscriptionManager.getSubscription(sub.id);\n              if (updated) {\n                this.webhookManager.sendSubscriptionEvent('subscription.past_due', updated, link).catch(err => {\n                  console.error('Webhook error:', err);\n                });\n              }\n            }\n          } else if (sub.status === 'active') {\n            // Send payment due webhook\n            if (this.webhookManager) {\n              this.webhookManager.sendSubscriptionEvent('subscription.payment_due', sub, link).catch(err => {\n                console.error('Webhook error:', err);\n              });\n            }\n          }\n        }\n      } catch (error) {\n        console.error('Subscription check error:', error);\n      }\n    }, 60000);\n  }\n\n  /**\n   * Stop subscription check\n   */\n  stopSubscriptionCheck(): void {\n    if (this.subscriptionCheckInterval) {\n      clearInterval(this.subscriptionCheckInterval);\n      this.subscriptionCheckInterval = undefined;\n    }\n  }\n\n  /**\n   * Start periodic installment check\n   */\n  private startInstallmentCheck(): void {\n    // Check every 5 minutes\n    this.installmentCheckInterval = setInterval(async () => {\n      try {\n        // Check for overdue installments\n        const overduePlans = await this.installmentManager.getOverduePlans();\n        \n        for (const plan of overduePlans) {\n          if (plan.status === 'active') {\n            const link = await this.storage.getPayLink(plan.payLinkId);\n            if (!link?.installment?.autoSuspend) continue;\n\n            // Suspend the plan\n            const suspended = await this.installmentManager.suspendPlan(plan.id, 'Payment overdue');\n            \n            if (this.webhookManager && link) {\n              this.webhookManager.sendInstallmentEvent('installment.plan_suspended', suspended, link).catch(err => {\n                console.error('Installment webhook error:', err);\n              });\n            }\n          }\n        }\n\n        // Send payment due reminders (3 days before)\n        const dueSoon = await this.installmentManager.getPlansDueSoon(3);\n        for (const plan of dueSoon) {\n          if (plan.status !== 'active') continue;\n          \n          const link = await this.storage.getPayLink(plan.payLinkId);\n          if (!link) continue;\n\n          if (this.webhookManager) {\n            this.webhookManager.sendInstallmentEvent('installment.payment_due', plan, link).catch(err => {\n              console.error('Installment webhook error:', err);\n            });\n          }\n        }\n      } catch (error) {\n        console.error('Installment check error:', error);\n      }\n    }, 300000); // 5 minutes\n  }\n\n  /**\n   * Stop installment check\n   */\n  stopInstallmentCheck(): void {\n    if (this.installmentCheckInterval) {\n      clearInterval(this.installmentCheckInterval);\n      this.installmentCheckInterval = undefined;\n    }\n  }\n\n  // ========================================\n  // PRIVATE METHODS\n  // ========================================\n\n  private setupMiddleware(): void {\n    this.app.use(helmet());\n    \n    if (this.config.cors) {\n      this.app.use(cors({ origin: '*', methods: ['GET', 'POST', 'DELETE'] }));\n    }\n    \n    this.app.use(express.json());\n    this.app.set('trust proxy', 1);\n\n    // Request logging\n    this.app.use((req, res, next) => {\n      const start = Date.now();\n      res.on('finish', () => {\n        console.log(`${req.method} ${req.path} ${res.statusCode} ${Date.now() - start}ms`);\n      });\n      next();\n    });\n  }\n\n  private setupRoutes(): void {\n    // Health check\n    this.app.get('/health', (req, res) => {\n      res.json({ status: 'ok', timestamp: new Date().toISOString() });\n    });\n\n    // API info\n    this.app.get('/', (req, res) => {\n      const base = this.config.baseUrl || `http://localhost:${this.config.port}`;\n      res.json({\n        name: 'Paylink Protocol',\n        version: '1.7.0',\n        chains: this.config.chains.map(c => ({ id: c.chainId, name: c.name, symbol: c.symbol })),\n        endpoints: {\n          paylink: `${base}${this.config.basePath}/:id`,\n          status: `${base}${this.config.basePath}/:id/status`,\n          confirm: `${base}${this.config.basePath}/:id/confirm`,\n          subscribe: `${base}${this.config.basePath}/:id/subscribe`,\n          installment: `${base}${this.config.basePath}/:id/installment`,\n        },\n      });\n    });\n\n    // Paylink routes\n    this.app.get(`${this.config.basePath}/:id`, this.handlePayLink.bind(this));\n    this.app.get(`${this.config.basePath}/:id/status`, this.handleStatus.bind(this));\n    this.app.post(`${this.config.basePath}/:id/confirm`, this.handleConfirm.bind(this));\n    this.app.get(`${this.config.basePath}/:id/qr`, this.handleQRCode.bind(this));\n    \n    // Subscription routes\n    this.app.post(`${this.config.basePath}/:id/subscribe`, this.handleSubscribe.bind(this));\n    this.app.get(`${this.config.basePath}/:id/subscription`, this.handleGetSubscription.bind(this));\n\n    // Admin API\n    if (this.config.apiKey) {\n      const auth = this.authMiddleware.bind(this);\n      this.app.post('/api/links', auth, this.apiCreateLink.bind(this));\n      this.app.get('/api/links', auth, this.apiListLinks.bind(this));\n      this.app.get('/api/links/:id', auth, this.apiGetLink.bind(this));\n      this.app.delete('/api/links/:id', auth, this.apiDeleteLink.bind(this));\n      this.app.get('/api/payments', auth, this.apiListPayments.bind(this));\n      \n      // Subscription admin routes\n      this.app.get('/api/subscriptions', auth, this.apiListSubscriptions.bind(this));\n      this.app.get('/api/subscriptions/:id', auth, this.apiGetSubscription.bind(this));\n      this.app.post('/api/subscriptions/:id/cancel', auth, this.apiCancelSubscription.bind(this));\n      this.app.post('/api/subscriptions/:id/pause', auth, this.apiPauseSubscription.bind(this));\n      this.app.post('/api/subscriptions/:id/resume', auth, this.apiResumeSubscription.bind(this));\n\n      // Referral admin routes\n      this.app.post('/api/referrals', auth, this.apiCreateReferral.bind(this));\n      this.app.get('/api/referrals', auth, this.apiListReferrals.bind(this));\n      this.app.get('/api/referrals/:id', auth, this.apiGetReferral.bind(this));\n      this.app.get('/api/referrals/code/:code', auth, this.apiGetReferralByCode.bind(this));\n      this.app.post('/api/referrals/:id/disable', auth, this.apiDisableReferral.bind(this));\n      this.app.get('/api/referrals/:id/stats', auth, this.apiGetReferralStats.bind(this));\n      this.app.get('/api/commissions', auth, this.apiListCommissions.bind(this));\n      this.app.get('/api/commissions/pending/:address', auth, this.apiGetPendingCommissions.bind(this));\n      this.app.post('/api/commissions/:id/payout', auth, this.apiMarkCommissionPaid.bind(this));\n\n      // Installment admin routes\n      this.app.post('/api/installments', auth, this.apiCreateInstallmentPlan.bind(this));\n      this.app.get('/api/installments', auth, this.apiListInstallmentPlans.bind(this));\n      this.app.get('/api/installments/:id', auth, this.apiGetInstallmentPlan.bind(this));\n      this.app.get('/api/installments/:id/schedule', auth, this.apiGetInstallmentSchedule.bind(this));\n      this.app.post('/api/installments/:id/payment', auth, this.apiProcessInstallmentPayment.bind(this));\n      this.app.post('/api/installments/:id/suspend', auth, this.apiSuspendInstallmentPlan.bind(this));\n      this.app.post('/api/installments/:id/cancel', auth, this.apiCancelInstallmentPlan.bind(this));\n      this.app.get('/api/installments/buyer/:address', auth, this.apiGetBuyerInstallments.bind(this));\n      this.app.get('/api/installments/overdue', auth, this.apiGetOverdueInstallments.bind(this));\n    }\n  }\n\n  private authMiddleware(req: Request, res: Response, next: NextFunction): void {\n    const key = req.headers['x-api-key'];\n    if (key !== this.config.apiKey) {\n      res.status(401).json({ error: 'Invalid API key' });\n      return;\n    }\n    next();\n  }\n\n  // ========================================\n  // PAYLINK HANDLERS\n  // ========================================\n\n  private async handlePayLink(req: Request, res: Response): Promise<void> {\n    try {\n      const link = await this.storage.getPayLink(req.params.id);\n\n      if (!link) {\n        res.status(404).json({ error: 'Payment link not found' });\n        return;\n      }\n\n      // Check if disabled\n      if (link.status !== 'active') {\n        this.send403(res, ReasonCode.LINK_DISABLED, link.id);\n        return;\n      }\n\n      // Check if expired\n      if (isExpired(link.expiresAt)) {\n        this.send403(res, ReasonCode.LINK_EXPIRED, link.id, {\n          expiredAt: link.expiresAt?.toISOString(),\n        });\n        return;\n      }\n\n      // Check usage limit (for non-subscription, non-multiUse links)\n      if (!link.subscription && !link.multiUse && isLimitReached(link.usedCount, link.maxUses)) {\n        this.send403(res, ReasonCode.LINK_USAGE_LIMIT_REACHED, link.id, {\n          maxUses: link.maxUses,\n          usedCount: link.usedCount,\n        });\n        return;\n      }\n\n      // Handle subscription links\n      if (link.subscription) {\n        const subscriberAddress = req.query.subscriber as string;\n        \n        if (subscriberAddress) {\n          const subscription = await this.storage.getSubscriptionByAddress(link.id, subscriberAddress);\n          \n          if (subscription) {\n            const access = await this.subscriptionManager.checkAccess(subscription, link);\n            \n            if (access.hasAccess) {\n              // Grant access\n              res.redirect(302, link.targetUrl);\n              return;\n            }\n            \n            // Check subscription status and return appropriate error\n            if (subscription.status === 'cancelled') {\n              this.send403(res, ReasonCode.SUBSCRIPTION_CANCELLED, link.id, {\n                subscriptionId: subscription.id,\n                cancelledAt: subscription.cancelledAt?.toISOString(),\n              });\n              return;\n            }\n            \n            if (subscription.status === 'paused') {\n              this.send403(res, ReasonCode.SUBSCRIPTION_PAUSED, link.id, {\n                subscriptionId: subscription.id,\n                pausedAt: subscription.pausedAt?.toISOString(),\n              });\n              return;\n            }\n            \n            if (subscription.status === 'expired') {\n              this.send403(res, ReasonCode.SUBSCRIPTION_EXPIRED, link.id, {\n                subscriptionId: subscription.id,\n              });\n              return;\n            }\n            \n            if (subscription.status === 'past_due') {\n              // Return 402 with subscription info for renewal\n              this.send402(res, link, subscription);\n              return;\n            }\n          }\n        }\n        \n        // No subscription or subscriber address - return 402 for new subscription\n        this.send402(res, link);\n        return;\n      }\n\n      // Handle multi-use links (requires payer address)\n      if (link.multiUse) {\n        const payerAddress = req.query.payer as string;\n        \n        if (!payerAddress) {\n          // No payer address provided - return 402 with info\n          this.send402(res, link);\n          return;\n        }\n        \n        // Check if this address has already paid\n        const payment = await this.storage.getConfirmedPaymentByAddress(link.id, payerAddress);\n        \n        if (payment) {\n          // Check maxUses limit if set\n          if (link.maxUses && (link.usedCount ?? 0) >= link.maxUses) {\n            this.send403(res, ReasonCode.LINK_USAGE_LIMIT_REACHED, link.id, {\n              maxUses: link.maxUses,\n              usedCount: link.usedCount,\n            });\n            return;\n          }\n          \n          // Increment usage and redirect\n          link.usedCount = (link.usedCount ?? 0) + 1;\n          await this.storage.updatePayLink(link);\n          res.redirect(302, link.targetUrl);\n          return;\n        }\n        \n        // No payment from this address - return 402\n        this.send402(res, link);\n        return;\n      }\n\n      // Standard single-use links: Check for any confirmed payment\n      const payment = await this.storage.getConfirmedPayment(link.id);\n\n      if (payment) {\n        // Increment usage and redirect\n        link.usedCount = (link.usedCount ?? 0) + 1;\n        await this.storage.updatePayLink(link);\n        res.redirect(302, link.targetUrl);\n        return;\n      }\n\n      // No payment - return 402\n      this.send402(res, link);\n    } catch (error) {\n      console.error('PayLink error:', error);\n      res.status(500).json({ error: 'Internal server error' });\n    }\n  }\n\n  private async handleStatus(req: Request, res: Response): Promise<void> {\n    try {\n      const link = await this.storage.getPayLink(req.params.id);\n\n      if (!link) {\n        res.json({ status: 'not_found' });\n        return;\n      }\n\n      if (link.status !== 'active') {\n        res.json({ status: 'forbidden' });\n        return;\n      }\n\n      if (isExpired(link.expiresAt)) {\n        res.json({ status: 'forbidden' });\n        return;\n      }\n\n      // For multi-use links, check by address\n      if (link.multiUse) {\n        const payerAddress = req.query.payer as string;\n        \n        if (!payerAddress) {\n          // Return link info without payment status\n          res.json({ \n            status: 'multiUse',\n            message: 'Provide ?payer=ADDRESS to check payment status',\n            totalPayments: (await this.storage.getPaymentsByLink(link.id)).filter(p => p.confirmed).length,\n          });\n          return;\n        }\n        \n        const payment = await this.storage.getConfirmedPaymentByAddress(link.id, payerAddress);\n        res.json({ \n          status: payment ? 'paid' : 'unpaid',\n          payerAddress,\n        });\n        return;\n      }\n\n      // For single-use links, check maxUses\n      if (isLimitReached(link.usedCount, link.maxUses)) {\n        res.json({ status: 'forbidden' });\n        return;\n      }\n\n      const payment = await this.storage.getConfirmedPayment(link.id);\n      res.json({ status: payment ? 'paid' : 'unpaid' });\n    } catch (error) {\n      console.error('Status error:', error);\n      res.status(500).json({ error: 'Internal server error' });\n    }\n  }\n\n  private async handleConfirm(req: Request, res: Response): Promise<void> {\n    try {\n      const { txHash, chainId: requestedChainId, referralCode } = req.body;\n\n      if (!txHash || typeof txHash !== 'string') {\n        res.status(400).json({ status: 'failed', message: 'Missing txHash' });\n        return;\n      }\n\n      const link = await this.storage.getPayLink(req.params.id);\n\n      if (!link) {\n        res.status(404).json({ status: 'failed', message: 'Link not found' });\n        return;\n      }\n\n      // Check if already confirmed\n      const existing = await this.storage.getPaymentByTxHash(txHash);\n      if (existing?.confirmed) {\n        res.json({ status: 'confirmed', message: 'Already confirmed' });\n        return;\n      }\n\n      // Determine which payment option to verify\n      let chainId = link.price.chainId;\n      let expectedAmount = link.price.amount;\n      let recipient = link.recipientAddress;\n      let tokenSymbol = link.price.tokenSymbol;\n\n      // If chainId provided in request, find matching payment option\n      if (requestedChainId !== undefined) {\n        const numChainId = Number(requestedChainId);\n        \n        if (numChainId === link.price.chainId) {\n          // Primary price matches\n          chainId = link.price.chainId;\n          expectedAmount = link.price.amount;\n          tokenSymbol = link.price.tokenSymbol;\n        } else if (link.paymentOptions) {\n          // Look for matching payment option\n          const option = link.paymentOptions.find(opt => opt.chainId === numChainId);\n          if (option) {\n            chainId = option.chainId;\n            expectedAmount = option.amount;\n            tokenSymbol = option.tokenSymbol;\n            recipient = option.recipientAddress || link.recipientAddress;\n          } else {\n            res.status(400).json({ status: 'failed', message: 'Chain not accepted for this payment link' });\n            return;\n          }\n        } else {\n          res.status(400).json({ status: 'failed', message: 'Chain not accepted for this payment link' });\n          return;\n        }\n      }\n\n      // Get verifier for chain\n      const verifier = this.verifiers.get(chainId);\n      if (!verifier) {\n        res.status(400).json({ status: 'failed', message: 'Chain not supported by server' });\n        return;\n      }\n\n      // Verify payment\n      const result = await verifier.verifyPayment({\n        txHash,\n        recipient,\n        amount: expectedAmount,\n      });\n\n      switch (result.status) {\n        case 'confirmed': {\n          const payment: Payment = {\n            id: generateUUID(),\n            payLinkId: link.id,\n            chainId,\n            txHash,\n            fromAddress: result.fromAddress ?? '',\n            amount: result.actualAmount ?? expectedAmount,\n            tokenSymbol,\n            confirmed: true,\n            createdAt: new Date(),\n            confirmedAt: new Date(),\n            referralCode: referralCode || undefined,\n          };\n          await this.storage.savePayment(payment);\n          \n          // Process referral commission if referral code provided\n          let commission = null;\n          if (referralCode && link.referral?.enabled) {\n            try {\n              commission = await this.referralManager.processReferralPayment(\n                payment,\n                link,\n                referralCode\n              );\n              \n              // Send webhook for commission\n              if (commission && this.webhookManager) {\n                const referral = await this.storage.getReferral(commission.referralId);\n                if (referral) {\n                  this.webhookManager.sendCommissionEvent(\n                    'commission.confirmed',\n                    commission,\n                    referral,\n                    link\n                  ).catch(err => {\n                    console.error('Commission webhook error:', err);\n                  });\n                }\n              }\n            } catch (err) {\n              console.error('Referral processing error:', err);\n              // Don't fail the payment if referral fails\n            }\n          }\n          \n          // Send webhook notification\n          if (this.webhookManager) {\n            this.webhookManager.sendPaymentEvent('payment.confirmed', payment, link).catch(err => {\n              console.error('Webhook error:', err);\n            });\n          }\n          \n          res.json({ \n            status: 'confirmed', \n            chainId, \n            tokenSymbol,\n            referral: commission ? {\n              commissionId: commission.id,\n              commissionAmount: commission.commissionAmount,\n            } : undefined,\n          });\n          break;\n        }\n        case 'pending':\n          // Send webhook for pending payment\n          if (this.webhookManager) {\n            const pendingPayment: Payment = {\n              id: generateUUID(),\n              payLinkId: link.id,\n              chainId,\n              txHash,\n              fromAddress: result.fromAddress ?? '',\n              amount: result.actualAmount ?? expectedAmount,\n              tokenSymbol,\n              confirmed: false,\n              createdAt: new Date(),\n            };\n            this.webhookManager.sendPaymentEvent('payment.pending', pendingPayment, link).catch(err => {\n              console.error('Webhook error:', err);\n            });\n          }\n          res.status(202).json({ status: 'pending', message: 'Transaction pending' });\n          break;\n        case 'underpaid':\n          // Send webhook for underpaid\n          if (this.webhookManager) {\n            const underpaidPayment: Payment = {\n              id: generateUUID(),\n              payLinkId: link.id,\n              chainId,\n              txHash,\n              fromAddress: result.fromAddress ?? '',\n              amount: result.actualAmount ?? '0',\n              confirmed: false,\n              createdAt: new Date(),\n            };\n            this.webhookManager.sendPaymentEvent('payment.underpaid', underpaidPayment, link).catch(err => {\n              console.error('Webhook error:', err);\n            });\n          }\n          res.status(400).json({\n            status: 'failed',\n            message: `Underpaid: received ${result.actualAmount}, required ${link.price.amount}`,\n          });\n          break;\n        default:\n          res.status(400).json({ status: 'failed', message: 'Transaction not found or failed' });\n      }\n    } catch (error) {\n      console.error('Confirm error:', error);\n      res.status(500).json({ error: 'Internal server error' });\n    }\n  }\n\n  /**\n   * Handle QR code generation\n   */\n  private async handleQRCode(req: Request, res: Response): Promise<void> {\n    try {\n      const link = await this.storage.getPayLink(req.params.id);\n\n      if (!link) {\n        res.status(404).json({ error: 'Payment link not found' });\n        return;\n      }\n\n      if (link.status !== 'active') {\n        res.status(403).json({ error: 'Payment link is not active' });\n        return;\n      }\n\n      const base = this.config.baseUrl || `http://localhost:${this.config.port}`;\n      const format = req.query.format as string || 'svg';\n      const size = parseInt(req.query.size as string) || 256;\n\n      const qrData: PaymentQRData = {\n        chainId: link.price.chainId,\n        recipient: link.recipientAddress,\n        amount: link.price.amount,\n        tokenSymbol: link.price.tokenSymbol,\n        payLinkId: link.id,\n        confirmUrl: `${base}${this.config.basePath}/${link.id}/confirm`,\n      };\n\n      const qr = generatePaymentQR(qrData, { size });\n\n      if (format === 'json') {\n        res.json({\n          payLinkId: link.id,\n          paymentUri: qr.uri,\n          qrCodeDataUrl: qr.dataUrl,\n          payment: {\n            chainId: link.price.chainId,\n            tokenSymbol: link.price.tokenSymbol,\n            amount: link.price.amount,\n            recipient: link.recipientAddress,\n          },\n        });\n        return;\n      }\n\n      // Return SVG directly\n      res.set({\n        'Content-Type': 'image/svg+xml',\n        'Cache-Control': 'public, max-age=300',\n      });\n      res.send(qr.svg);\n    } catch (error) {\n      console.error('QR code error:', error);\n      res.status(500).json({ error: 'Internal server error' });\n    }\n  }\n\n  // ========================================\n  // SUBSCRIPTION HANDLERS\n  // ========================================\n\n  /**\n   * Handle subscription creation/renewal\n   */\n  private async handleSubscribe(req: Request, res: Response): Promise<void> {\n    try {\n      const { subscriberAddress, txHash } = req.body;\n\n      if (!subscriberAddress) {\n        res.status(400).json({ error: 'Missing subscriberAddress' });\n        return;\n      }\n\n      const link = await this.storage.getPayLink(req.params.id);\n\n      if (!link) {\n        res.status(404).json({ error: 'Payment link not found' });\n        return;\n      }\n\n      if (!link.subscription) {\n        res.status(400).json({ error: 'This link does not support subscriptions' });\n        return;\n      }\n\n      // Check for existing subscription\n      let subscription = await this.storage.getSubscriptionByAddress(link.id, subscriberAddress);\n\n      // If txHash provided, verify payment first\n      if (txHash) {\n        const verifier = this.verifiers.get(link.price.chainId);\n        if (!verifier) {\n          res.status(400).json({ error: 'Chain not supported' });\n          return;\n        }\n\n        const result = await verifier.verifyPayment({\n          txHash,\n          recipient: link.recipientAddress,\n          amount: link.price.amount,\n        });\n\n        if (result.status !== 'confirmed') {\n          res.status(400).json({\n            error: 'Payment not confirmed',\n            status: result.status,\n          });\n          return;\n        }\n\n        // Save payment\n        const payment: Payment = {\n          id: generateUUID(),\n          payLinkId: link.id,\n          chainId: link.price.chainId,\n          txHash,\n          fromAddress: result.fromAddress ?? subscriberAddress,\n          amount: result.actualAmount ?? link.price.amount,\n          confirmed: true,\n          createdAt: new Date(),\n          confirmedAt: new Date(),\n        };\n        await this.storage.savePayment(payment);\n\n        // Send payment webhook\n        if (this.webhookManager) {\n          this.webhookManager.sendPaymentEvent('payment.confirmed', payment, link).catch(err => {\n            console.error('Webhook error:', err);\n          });\n        }\n\n        if (subscription) {\n          // Renew existing subscription\n          subscription = await this.subscriptionManager.processPayment(subscription, payment, link);\n\n          if (this.webhookManager) {\n            this.webhookManager.sendSubscriptionEvent('subscription.renewed', subscription, link).catch(err => {\n              console.error('Webhook error:', err);\n            });\n          }\n\n          res.json({\n            success: true,\n            action: 'renewed',\n            subscription: this.formatSubscriptionResponse(subscription, link),\n          });\n          return;\n        }\n      }\n\n      // Create new subscription\n      if (!subscription) {\n        subscription = await this.createSubscription(link.id, subscriberAddress);\n\n        res.status(201).json({\n          success: true,\n          action: 'created',\n          subscription: this.formatSubscriptionResponse(subscription, link),\n        });\n        return;\n      }\n\n      // Return existing subscription info\n      res.json({\n        success: true,\n        action: 'existing',\n        subscription: this.formatSubscriptionResponse(subscription, link),\n      });\n    } catch (error) {\n      console.error('Subscribe error:', error);\n      res.status(500).json({ error: 'Internal server error' });\n    }\n  }\n\n  /**\n   * Handle get subscription status\n   */\n  private async handleGetSubscription(req: Request, res: Response): Promise<void> {\n    try {\n      const subscriberAddress = req.query.subscriber as string;\n\n      if (!subscriberAddress) {\n        res.status(400).json({ error: 'Missing subscriber query parameter' });\n        return;\n      }\n\n      const link = await this.storage.getPayLink(req.params.id);\n\n      if (!link) {\n        res.status(404).json({ error: 'Payment link not found' });\n        return;\n      }\n\n      const subscription = await this.storage.getSubscriptionByAddress(link.id, subscriberAddress);\n\n      if (!subscription) {\n        res.status(404).json({ error: 'Subscription not found' });\n        return;\n      }\n\n      const access = await this.subscriptionManager.checkAccess(subscription, link);\n\n      res.json({\n        subscription: this.formatSubscriptionResponse(subscription, link),\n        access: {\n          hasAccess: access.hasAccess,\n          reason: access.reason,\n          requiresPayment: access.requiresPayment,\n        },\n      });\n    } catch (error) {\n      console.error('Get subscription error:', error);\n      res.status(500).json({ error: 'Internal server error' });\n    }\n  }\n\n  /**\n   * Format subscription for response\n   */\n  private formatSubscriptionResponse(subscription: Subscription, link: PayLink) {\n    const base = this.config.baseUrl || `http://localhost:${this.config.port}`;\n    \n    return {\n      id: subscription.id,\n      payLinkId: subscription.payLinkId,\n      subscriberAddress: subscription.subscriberAddress,\n      status: subscription.status,\n      interval: link.subscription?.interval,\n      intervalCount: link.subscription?.intervalCount ?? 1,\n      currentPeriodStart: subscription.currentPeriodStart.toISOString(),\n      currentPeriodEnd: subscription.currentPeriodEnd.toISOString(),\n      nextPaymentDue: subscription.nextPaymentDue.toISOString(),\n      cycleCount: subscription.cycleCount,\n      trialEndsAt: subscription.trialEndsAt?.toISOString(),\n      cancelledAt: subscription.cancelledAt?.toISOString(),\n      pausedAt: subscription.pausedAt?.toISOString(),\n      createdAt: subscription.createdAt.toISOString(),\n      price: link.price,\n      renewUrl: `${base}${this.config.basePath}/${link.id}/subscribe`,\n    };\n  }\n\n  // ========================================\n  // ADMIN API HANDLERS\n  // ========================================\n\n  private async apiCreateLink(req: Request, res: Response): Promise<void> {\n    try {\n      const {\n        targetUrl,\n        amount,\n        tokenSymbol = 'ETH',\n        chainId = 1,\n        recipientAddress,\n        description,\n        maxUses,\n        expiresIn,\n        // Multi-currency payment options\n        paymentOptions,\n        // Subscription fields\n        subscription,\n        // Multi-use mode\n        multiUse,\n        // Referral configuration\n        referral,\n      } = req.body;\n\n      if (!targetUrl || !amount || !recipientAddress) {\n        res.status(400).json({ error: 'Missing: targetUrl, amount, or recipientAddress' });\n        return;\n      }\n\n      // Parse payment options if provided\n      let parsedPaymentOptions: PaymentOption[] | undefined;\n      if (paymentOptions && Array.isArray(paymentOptions)) {\n        parsedPaymentOptions = paymentOptions.map((opt: any) => ({\n          tokenSymbol: opt.tokenSymbol,\n          chainId: Number(opt.chainId),\n          amount: String(opt.amount),\n          recipientAddress: opt.recipientAddress,\n        }));\n      }\n\n      // Parse subscription config if provided\n      let subscriptionConfig;\n      if (subscription) {\n        if (!subscription.interval || !['daily', 'weekly', 'monthly', 'yearly'].includes(subscription.interval)) {\n          res.status(400).json({ error: 'Invalid subscription interval. Must be: daily, weekly, monthly, or yearly' });\n          return;\n        }\n        subscriptionConfig = {\n          interval: subscription.interval,\n          intervalCount: subscription.intervalCount ? Number(subscription.intervalCount) : 1,\n          gracePeriodHours: subscription.gracePeriodHours ? Number(subscription.gracePeriodHours) : 24,\n          maxCycles: subscription.maxCycles ? Number(subscription.maxCycles) : undefined,\n          trialDays: subscription.trialDays ? Number(subscription.trialDays) : 0,\n        };\n      }\n\n      // Parse referral config if provided\n      let referralConfig;\n      if (referral && referral.enabled) {\n        referralConfig = {\n          enabled: true,\n          commissionPercent: referral.commissionPercent ? Number(referral.commissionPercent) : 10,\n          minPayoutThreshold: referral.minPayoutThreshold ? String(referral.minPayoutThreshold) : undefined,\n          expirationDays: referral.expirationDays ? Number(referral.expirationDays) : undefined,\n        };\n      }\n\n      const link = await this.createPayLink({\n        targetUrl,\n        price: { amount: String(amount), tokenSymbol, chainId: Number(chainId) },\n        paymentOptions: parsedPaymentOptions,\n        recipientAddress,\n        description,\n        maxUses: maxUses ? Number(maxUses) : undefined,\n        expiresAt: expiresIn ? new Date(Date.now() + Number(expiresIn) * 1000) : undefined,\n        subscription: subscriptionConfig,\n        multiUse: multiUse === true || multiUse === 'true',\n        referral: referralConfig,\n      });\n\n      const base = this.config.baseUrl || `http://localhost:${this.config.port}`;\n\n      res.status(201).json({\n        success: true,\n        link: {\n          id: link.id,\n          url: `${base}${this.config.basePath}/${link.id}`,\n          targetUrl: link.targetUrl,\n          price: link.price,\n          paymentOptions: link.paymentOptions,\n          recipientAddress: link.recipientAddress,\n          description: link.description,\n          maxUses: link.maxUses,\n          multiUse: link.multiUse,\n          expiresAt: link.expiresAt?.toISOString(),\n          subscription: link.subscription ? {\n            interval: link.subscription.interval,\n            intervalCount: link.subscription.intervalCount,\n            gracePeriodHours: link.subscription.gracePeriodHours,\n            maxCycles: link.subscription.maxCycles,\n            trialDays: link.subscription.trialDays,\n            subscribeUrl: `${base}${this.config.basePath}/${link.id}/subscribe`,\n          } : undefined,\n          referral: link.referral ? {\n            enabled: link.referral.enabled,\n            commissionPercent: link.referral.commissionPercent,\n            minPayoutThreshold: link.referral.minPayoutThreshold,\n            expirationDays: link.referral.expirationDays,\n          } : undefined,\n        },\n      });\n    } catch (error) {\n      console.error('Create link error:', error);\n      res.status(500).json({ error: 'Internal server error' });\n    }\n  }\n\n  private async apiListLinks(req: Request, res: Response): Promise<void> {\n    const links = await this.storage.getAllPayLinks();\n    const base = this.config.baseUrl || `http://localhost:${this.config.port}`;\n\n    res.json({\n      count: links.length,\n      links: links.map(l => ({\n        id: l.id,\n        url: `${base}${this.config.basePath}/${l.id}`,\n        status: l.status,\n        price: l.price,\n        usedCount: l.usedCount,\n        isSubscription: !!l.subscription,\n        subscription: l.subscription,\n      })),\n    });\n  }\n\n  private async apiGetLink(req: Request, res: Response): Promise<void> {\n    const link = await this.storage.getPayLink(req.params.id);\n\n    if (!link) {\n      res.status(404).json({ error: 'Link not found' });\n      return;\n    }\n\n    const base = this.config.baseUrl || `http://localhost:${this.config.port}`;\n\n    res.json({\n      id: link.id,\n      url: `${base}${this.config.basePath}/${link.id}`,\n      targetUrl: link.targetUrl,\n      price: link.price,\n      recipientAddress: link.recipientAddress,\n      status: link.status,\n      usedCount: link.usedCount,\n      maxUses: link.maxUses,\n      expiresAt: link.expiresAt?.toISOString(),\n      createdAt: link.createdAt.toISOString(),\n    });\n  }\n\n  private async apiDeleteLink(req: Request, res: Response): Promise<void> {\n    try {\n      await this.disablePayLink(req.params.id);\n      res.json({ success: true });\n    } catch {\n      res.status(404).json({ error: 'Link not found' });\n    }\n  }\n\n  private async apiListPayments(req: Request, res: Response): Promise<void> {\n    const payments = await this.storage.getAllPayments();\n\n    res.json({\n      count: payments.length,\n      payments: payments.map(p => ({\n        id: p.id,\n        payLinkId: p.payLinkId,\n        txHash: p.txHash,\n        amount: p.amount,\n        confirmed: p.confirmed,\n        createdAt: p.createdAt.toISOString(),\n      })),\n    });\n  }\n\n  // ========================================\n  // SUBSCRIPTION ADMIN ENDPOINTS\n  // ========================================\n\n  private async apiListSubscriptions(req: Request, res: Response): Promise<void> {\n    const subscriptions = await this.storage.getAllSubscriptions();\n    \n    res.json({\n      count: subscriptions.length,\n      subscriptions: subscriptions.map(s => ({\n        id: s.id,\n        payLinkId: s.payLinkId,\n        subscriberAddress: s.subscriberAddress,\n        status: s.status,\n        cycleCount: s.cycleCount,\n        nextPaymentDue: s.nextPaymentDue.toISOString(),\n        createdAt: s.createdAt.toISOString(),\n      })),\n    });\n  }\n\n  private async apiGetSubscription(req: Request, res: Response): Promise<void> {\n    const subscription = await this.storage.getSubscription(req.params.id);\n    \n    if (!subscription) {\n      res.status(404).json({ error: 'Subscription not found' });\n      return;\n    }\n\n    const link = await this.storage.getPayLink(subscription.payLinkId);\n\n    res.json({\n      id: subscription.id,\n      payLinkId: subscription.payLinkId,\n      subscriberAddress: subscription.subscriberAddress,\n      status: subscription.status,\n      currentPeriodStart: subscription.currentPeriodStart.toISOString(),\n      currentPeriodEnd: subscription.currentPeriodEnd.toISOString(),\n      nextPaymentDue: subscription.nextPaymentDue.toISOString(),\n      cycleCount: subscription.cycleCount,\n      lastPaymentId: subscription.lastPaymentId,\n      trialEndsAt: subscription.trialEndsAt?.toISOString(),\n      cancelledAt: subscription.cancelledAt?.toISOString(),\n      pausedAt: subscription.pausedAt?.toISOString(),\n      createdAt: subscription.createdAt.toISOString(),\n      updatedAt: subscription.updatedAt.toISOString(),\n      payLink: link ? {\n        id: link.id,\n        targetUrl: link.targetUrl,\n        price: link.price,\n        subscription: link.subscription,\n      } : undefined,\n    });\n  }\n\n  private async apiCancelSubscription(req: Request, res: Response): Promise<void> {\n    try {\n      const subscription = await this.cancelSubscription(req.params.id);\n      res.json({ success: true, subscription: { id: subscription.id, status: subscription.status } });\n    } catch (error) {\n      res.status(404).json({ error: (error as Error).message });\n    }\n  }\n\n  private async apiPauseSubscription(req: Request, res: Response): Promise<void> {\n    try {\n      const subscription = await this.pauseSubscription(req.params.id);\n      res.json({ success: true, subscription: { id: subscription.id, status: subscription.status } });\n    } catch (error) {\n      res.status(400).json({ error: (error as Error).message });\n    }\n  }\n\n  private async apiResumeSubscription(req: Request, res: Response): Promise<void> {\n    try {\n      const subscription = await this.resumeSubscription(req.params.id);\n      res.json({ success: true, subscription: { id: subscription.id, status: subscription.status } });\n    } catch (error) {\n      res.status(400).json({ error: (error as Error).message });\n    }\n  }\n\n  // ========================================\n  // REFERRAL ADMIN ENDPOINTS\n  // ========================================\n\n  private async apiCreateReferral(req: Request, res: Response): Promise<void> {\n    try {\n      const { payLinkId, referrerAddress, code, metadata } = req.body;\n\n      if (!payLinkId || !referrerAddress) {\n        res.status(400).json({ error: 'Missing: payLinkId or referrerAddress' });\n        return;\n      }\n\n      const referral = await this.referralManager.createReferral({\n        payLinkId,\n        referrerAddress,\n        code,\n        metadata,\n      });\n\n      const link = await this.storage.getPayLink(payLinkId);\n      const base = this.config.baseUrl || `http://localhost:${this.config.port}`;\n\n      // Send webhook\n      if (this.webhookManager && link) {\n        this.webhookManager.sendReferralEvent('referral.created', referral, link).catch(err => {\n          console.error('Referral webhook error:', err);\n        });\n      }\n\n      res.status(201).json({\n        success: true,\n        referral: {\n          id: referral.id,\n          code: referral.code,\n          referrerAddress: referral.referrerAddress,\n          payLinkId: referral.payLinkId,\n          status: referral.status,\n          referralUrl: buildReferralUrl(base, payLinkId, referral.code),\n          createdAt: referral.createdAt.toISOString(),\n        },\n      });\n    } catch (error) {\n      console.error('Create referral error:', error);\n      res.status(400).json({ error: (error as Error).message });\n    }\n  }\n\n  private async apiListReferrals(req: Request, res: Response): Promise<void> {\n    try {\n      const { payLinkId, referrerAddress } = req.query;\n\n      let referrals: Referral[];\n      \n      if (payLinkId) {\n        referrals = await this.storage.getReferralsByPayLink(payLinkId as string);\n      } else if (referrerAddress) {\n        referrals = await this.storage.getReferralsByReferrer(referrerAddress as string);\n      } else {\n        referrals = await this.storage.getAllReferrals();\n      }\n\n      const base = this.config.baseUrl || `http://localhost:${this.config.port}`;\n\n      res.json({\n        count: referrals.length,\n        referrals: referrals.map(r => ({\n          id: r.id,\n          code: r.code,\n          referrerAddress: r.referrerAddress,\n          payLinkId: r.payLinkId,\n          totalReferrals: r.totalReferrals,\n          confirmedReferrals: r.confirmedReferrals,\n          totalEarned: r.totalEarned,\n          pendingAmount: r.pendingAmount,\n          paidAmount: r.paidAmount,\n          status: r.status,\n          referralUrl: buildReferralUrl(base, r.payLinkId, r.code),\n          createdAt: r.createdAt.toISOString(),\n        })),\n      });\n    } catch (error) {\n      console.error('List referrals error:', error);\n      res.status(500).json({ error: 'Internal server error' });\n    }\n  }\n\n  private async apiGetReferral(req: Request, res: Response): Promise<void> {\n    try {\n      const referral = await this.storage.getReferral(req.params.id);\n\n      if (!referral) {\n        res.status(404).json({ error: 'Referral not found' });\n        return;\n      }\n\n      const base = this.config.baseUrl || `http://localhost:${this.config.port}`;\n\n      res.json({\n        id: referral.id,\n        code: referral.code,\n        referrerAddress: referral.referrerAddress,\n        payLinkId: referral.payLinkId,\n        totalReferrals: referral.totalReferrals,\n        confirmedReferrals: referral.confirmedReferrals,\n        totalEarned: referral.totalEarned,\n        pendingAmount: referral.pendingAmount,\n        paidAmount: referral.paidAmount,\n        status: referral.status,\n        referralUrl: buildReferralUrl(base, referral.payLinkId, referral.code),\n        createdAt: referral.createdAt.toISOString(),\n        updatedAt: referral.updatedAt.toISOString(),\n        metadata: referral.metadata,\n      });\n    } catch (error) {\n      console.error('Get referral error:', error);\n      res.status(500).json({ error: 'Internal server error' });\n    }\n  }\n\n  private async apiGetReferralByCode(req: Request, res: Response): Promise<void> {\n    try {\n      const referral = await this.storage.getReferralByCode(req.params.code);\n\n      if (!referral) {\n        res.status(404).json({ error: 'Referral not found' });\n        return;\n      }\n\n      const base = this.config.baseUrl || `http://localhost:${this.config.port}`;\n\n      res.json({\n        id: referral.id,\n        code: referral.code,\n        referrerAddress: referral.referrerAddress,\n        payLinkId: referral.payLinkId,\n        totalReferrals: referral.totalReferrals,\n        confirmedReferrals: referral.confirmedReferrals,\n        totalEarned: referral.totalEarned,\n        pendingAmount: referral.pendingAmount,\n        status: referral.status,\n        referralUrl: buildReferralUrl(base, referral.payLinkId, referral.code),\n        createdAt: referral.createdAt.toISOString(),\n      });\n    } catch (error) {\n      console.error('Get referral by code error:', error);\n      res.status(500).json({ error: 'Internal server error' });\n    }\n  }\n\n  private async apiDisableReferral(req: Request, res: Response): Promise<void> {\n    try {\n      const referral = await this.referralManager.disableReferral(req.params.id);\n\n      const link = await this.storage.getPayLink(referral.payLinkId);\n\n      // Send webhook\n      if (this.webhookManager && link) {\n        this.webhookManager.sendReferralEvent('referral.disabled', referral, link).catch(err => {\n          console.error('Referral webhook error:', err);\n        });\n      }\n\n      res.json({ success: true, referral: { id: referral.id, status: referral.status } });\n    } catch (error) {\n      res.status(404).json({ error: (error as Error).message });\n    }\n  }\n\n  private async apiGetReferralStats(req: Request, res: Response): Promise<void> {\n    try {\n      const referral = await this.storage.getReferral(req.params.id);\n\n      if (!referral) {\n        res.status(404).json({ error: 'Referral not found' });\n        return;\n      }\n\n      const stats = await this.referralManager.getStats(referral.referrerAddress);\n\n      res.json({\n        referralId: referral.id,\n        code: referral.code,\n        stats,\n      });\n    } catch (error) {\n      console.error('Get referral stats error:', error);\n      res.status(500).json({ error: 'Internal server error' });\n    }\n  }\n\n  private async apiListCommissions(req: Request, res: Response): Promise<void> {\n    try {\n      const { referralId, referrerAddress, status } = req.query;\n\n      let commissions: ReferralCommission[];\n\n      if (referralId) {\n        commissions = await this.storage.getCommissionsByReferral(referralId as string);\n      } else if (referrerAddress) {\n        commissions = await this.storage.getCommissionsByReferrer(referrerAddress as string);\n      } else {\n        commissions = await this.storage.getAllCommissions();\n      }\n\n      // Filter by status if provided\n      if (status) {\n        commissions = commissions.filter(c => c.status === status);\n      }\n\n      res.json({\n        count: commissions.length,\n        commissions: commissions.map(c => ({\n          id: c.id,\n          referralId: c.referralId,\n          paymentId: c.paymentId,\n          payLinkId: c.payLinkId,\n          referrerAddress: c.referrerAddress,\n          referredAddress: c.referredAddress,\n          paymentAmount: c.paymentAmount,\n          commissionAmount: c.commissionAmount,\n          commissionPercent: c.commissionPercent,\n          tokenSymbol: c.tokenSymbol,\n          chainId: c.chainId,\n          status: c.status,\n          createdAt: c.createdAt.toISOString(),\n          confirmedAt: c.confirmedAt?.toISOString(),\n          paidAt: c.paidAt?.toISOString(),\n          payoutTxHash: c.payoutTxHash,\n        })),\n      });\n    } catch (error) {\n      console.error('List commissions error:', error);\n      res.status(500).json({ error: 'Internal server error' });\n    }\n  }\n\n  private async apiGetPendingCommissions(req: Request, res: Response): Promise<void> {\n    try {\n      const commissions = await this.referralManager.getPendingCommissions(req.params.address);\n\n      // Calculate total pending\n      const totalPending = commissions.reduce(\n        (sum, c) => sum + parseFloat(c.commissionAmount),\n        0\n      );\n\n      res.json({\n        address: req.params.address,\n        count: commissions.length,\n        totalPending: totalPending.toString(),\n        commissions: commissions.map(c => ({\n          id: c.id,\n          referralId: c.referralId,\n          commissionAmount: c.commissionAmount,\n          tokenSymbol: c.tokenSymbol,\n          chainId: c.chainId,\n          createdAt: c.createdAt.toISOString(),\n          confirmedAt: c.confirmedAt?.toISOString(),\n        })),\n      });\n    } catch (error) {\n      console.error('Get pending commissions error:', error);\n      res.status(500).json({ error: 'Internal server error' });\n    }\n  }\n\n  private async apiMarkCommissionPaid(req: Request, res: Response): Promise<void> {\n    try {\n      const { payoutTxHash } = req.body;\n\n      if (!payoutTxHash) {\n        res.status(400).json({ error: 'Missing payoutTxHash' });\n        return;\n      }\n\n      const commission = await this.referralManager.markCommissionPaid(\n        req.params.id,\n        payoutTxHash\n      );\n\n      const referral = await this.storage.getReferral(commission.referralId);\n      const link = await this.storage.getPayLink(commission.payLinkId);\n\n      // Send webhook\n      if (this.webhookManager && referral && link) {\n        this.webhookManager.sendCommissionEvent('commission.paid', commission, referral, link).catch(err => {\n          console.error('Commission webhook error:', err);\n        });\n      }\n\n      res.json({\n        success: true,\n        commission: {\n          id: commission.id,\n          status: commission.status,\n          payoutTxHash: commission.payoutTxHash,\n          paidAt: commission.paidAt?.toISOString(),\n        },\n      });\n    } catch (error) {\n      res.status(400).json({ error: (error as Error).message });\n    }\n  }\n\n  // ========================================\n  // INSTALLMENT API HANDLERS\n  // ========================================\n\n  private async apiCreateInstallmentPlan(req: Request, res: Response): Promise<void> {\n    try {\n      const { payLinkId, buyerAddress, metadata } = req.body;\n\n      if (!payLinkId || !buyerAddress) {\n        res.status(400).json({ error: 'Missing required fields: payLinkId, buyerAddress' });\n        return;\n      }\n\n      const plan = await this.installmentManager.createPlan({\n        payLinkId,\n        buyerAddress,\n        metadata,\n      });\n\n      const link = await this.storage.getPayLink(payLinkId);\n\n      // Send webhook\n      if (this.webhookManager && link) {\n        this.webhookManager.sendInstallmentEvent('installment.plan_created', plan, link).catch(err => {\n          console.error('Installment webhook error:', err);\n        });\n      }\n\n      res.status(201).json({\n        id: plan.id,\n        payLinkId: plan.payLinkId,\n        buyerAddress: plan.buyerAddress,\n        status: plan.status,\n        totalAmount: plan.totalAmount,\n        totalInstallments: plan.totalInstallments,\n        installmentAmounts: plan.installmentAmounts,\n        intervalDays: plan.intervalDays,\n        nextDueDate: plan.nextDueDate.toISOString(),\n        nextInstallmentNumber: plan.nextInstallmentNumber,\n        createdAt: plan.createdAt.toISOString(),\n      });\n    } catch (error) {\n      res.status(400).json({ error: (error as Error).message });\n    }\n  }\n\n  private async apiListInstallmentPlans(req: Request, res: Response): Promise<void> {\n    try {\n      const { payLinkId, buyerAddress, status } = req.query;\n\n      let plans: InstallmentPlan[];\n\n      if (payLinkId) {\n        plans = await this.storage.getInstallmentPlansByPayLink(payLinkId as string);\n      } else if (buyerAddress) {\n        plans = await this.storage.getInstallmentPlansByBuyer(buyerAddress as string);\n      } else {\n        plans = await this.storage.getAllInstallmentPlans();\n      }\n\n      // Filter by status if provided\n      if (status) {\n        plans = plans.filter(p => p.status === status);\n      }\n\n      res.json({\n        count: plans.length,\n        plans: plans.map(p => ({\n          id: p.id,\n          payLinkId: p.payLinkId,\n          buyerAddress: p.buyerAddress,\n          status: p.status,\n          totalAmount: p.totalAmount,\n          paidAmount: p.paidAmount,\n          totalInstallments: p.totalInstallments,\n          completedInstallments: p.completedInstallments,\n          nextDueDate: p.nextDueDate.toISOString(),\n          nextInstallmentNumber: p.nextInstallmentNumber,\n          createdAt: p.createdAt.toISOString(),\n          progress: getInstallmentProgress(p),\n        })),\n      });\n    } catch (error) {\n      console.error('List installment plans error:', error);\n      res.status(500).json({ error: 'Internal server error' });\n    }\n  }\n\n  private async apiGetInstallmentPlan(req: Request, res: Response): Promise<void> {\n    try {\n      const details = await this.installmentManager.getPlanDetails(req.params.id);\n\n      if (!details) {\n        res.status(404).json({ error: 'Installment plan not found' });\n        return;\n      }\n\n      const { plan, payments, schedule, progress } = details;\n\n      res.json({\n        id: plan.id,\n        payLinkId: plan.payLinkId,\n        buyerAddress: plan.buyerAddress,\n        status: plan.status,\n        totalAmount: plan.totalAmount,\n        paidAmount: plan.paidAmount,\n        totalInstallments: plan.totalInstallments,\n        completedInstallments: plan.completedInstallments,\n        installmentAmounts: plan.installmentAmounts,\n        intervalDays: plan.intervalDays,\n        gracePeriodDays: plan.gracePeriodDays,\n        nextDueDate: plan.nextDueDate.toISOString(),\n        nextInstallmentNumber: plan.nextInstallmentNumber,\n        createdAt: plan.createdAt.toISOString(),\n        updatedAt: plan.updatedAt.toISOString(),\n        activatedAt: plan.activatedAt?.toISOString(),\n        completedAt: plan.completedAt?.toISOString(),\n        suspendedAt: plan.suspendedAt?.toISOString(),\n        cancelledAt: plan.cancelledAt?.toISOString(),\n        progress,\n        schedule,\n        payments: payments.map(p => ({\n          id: p.id,\n          installmentNumber: p.installmentNumber,\n          amount: p.amount,\n          expectedAmount: p.expectedAmount,\n          txHash: p.txHash,\n          status: p.status,\n          dueDate: p.dueDate.toISOString(),\n          createdAt: p.createdAt.toISOString(),\n          confirmedAt: p.confirmedAt?.toISOString(),\n        })),\n      });\n    } catch (error) {\n      console.error('Get installment plan error:', error);\n      res.status(500).json({ error: 'Internal server error' });\n    }\n  }\n\n  private async apiGetInstallmentSchedule(req: Request, res: Response): Promise<void> {\n    try {\n      const details = await this.installmentManager.getPlanDetails(req.params.id);\n\n      if (!details) {\n        res.status(404).json({ error: 'Installment plan not found' });\n        return;\n      }\n\n      res.json({\n        planId: details.plan.id,\n        totalAmount: details.plan.totalAmount,\n        paidAmount: details.plan.paidAmount,\n        progress: details.progress,\n        schedule: details.schedule,\n      });\n    } catch (error) {\n      console.error('Get installment schedule error:', error);\n      res.status(500).json({ error: 'Internal server error' });\n    }\n  }\n\n  private async apiProcessInstallmentPayment(req: Request, res: Response): Promise<void> {\n    try {\n      const { txHash, chainId } = req.body;\n\n      if (!txHash || !chainId) {\n        res.status(400).json({ error: 'Missing required fields: txHash, chainId' });\n        return;\n      }\n\n      const plan = await this.storage.getInstallmentPlan(req.params.id);\n      if (!plan) {\n        res.status(404).json({ error: 'Installment plan not found' });\n        return;\n      }\n\n      const link = await this.storage.getPayLink(plan.payLinkId);\n      if (!link) {\n        res.status(404).json({ error: 'PayLink not found' });\n        return;\n      }\n\n      // Get verifier\n      const verifier = this.verifiers.get(chainId);\n      if (!verifier) {\n        res.status(400).json({ error: 'Unsupported chain' });\n        return;\n      }\n\n      // Verify payment\n      const expectedAmount = plan.installmentAmounts[plan.nextInstallmentNumber - 1];\n      const result = await verifier.verifyPayment({\n        txHash,\n        recipient: link.recipientAddress,\n        amount: expectedAmount,\n      });\n\n      if (result.status !== 'confirmed') {\n        res.status(400).json({ error: 'Payment not confirmed', status: result.status });\n        return;\n      }\n\n      // Create payment record\n      const payment: Payment = {\n        id: generateUUID(),\n        payLinkId: plan.payLinkId,\n        chainId,\n        txHash,\n        fromAddress: result.fromAddress || plan.buyerAddress,\n        amount: result.actualAmount || expectedAmount,\n        tokenSymbol: link.price.tokenSymbol,\n        confirmed: true,\n        createdAt: new Date(),\n        confirmedAt: new Date(),\n      };\n      await this.storage.savePayment(payment);\n\n      // Process installment payment\n      const installmentPayment = await this.installmentManager.processPayment(plan.id, payment);\n\n      // Send webhook for payment received\n      if (this.webhookManager && link) {\n        this.webhookManager.sendInstallmentEvent('installment.payment_received', plan, link, installmentPayment).catch(err => {\n          console.error('Installment webhook error:', err);\n        });\n      }\n\n      // Confirm the installment payment\n      const { payment: confirmedPayment, plan: updatedPlan } = await this.installmentManager.confirmPayment(installmentPayment.id);\n\n      // Send appropriate webhook\n      if (this.webhookManager && link) {\n        if (updatedPlan.status === 'active' && updatedPlan.completedInstallments === 1) {\n          this.webhookManager.sendInstallmentEvent('installment.plan_activated', updatedPlan, link, confirmedPayment).catch(err => {\n            console.error('Installment webhook error:', err);\n          });\n        }\n\n        if (updatedPlan.status === 'completed') {\n          this.webhookManager.sendInstallmentEvent('installment.plan_completed', updatedPlan, link, confirmedPayment).catch(err => {\n            console.error('Installment webhook error:', err);\n          });\n        }\n\n        this.webhookManager.sendInstallmentEvent('installment.payment_confirmed', updatedPlan, link, confirmedPayment).catch(err => {\n          console.error('Installment webhook error:', err);\n        });\n      }\n\n      const progress = getInstallmentProgress(updatedPlan);\n\n      res.json({\n        success: true,\n        payment: {\n          id: confirmedPayment.id,\n          installmentNumber: confirmedPayment.installmentNumber,\n          amount: confirmedPayment.amount,\n          status: confirmedPayment.status,\n          confirmedAt: confirmedPayment.confirmedAt?.toISOString(),\n        },\n        plan: {\n          id: updatedPlan.id,\n          status: updatedPlan.status,\n          completedInstallments: updatedPlan.completedInstallments,\n          paidAmount: updatedPlan.paidAmount,\n          nextDueDate: updatedPlan.nextDueDate?.toISOString(),\n          nextInstallmentNumber: updatedPlan.nextInstallmentNumber,\n        },\n        progress,\n      });\n    } catch (error) {\n      res.status(400).json({ error: (error as Error).message });\n    }\n  }\n\n  private async apiSuspendInstallmentPlan(req: Request, res: Response): Promise<void> {\n    try {\n      const { reason } = req.body;\n\n      const plan = await this.installmentManager.suspendPlan(req.params.id, reason);\n      const link = await this.storage.getPayLink(plan.payLinkId);\n\n      // Send webhook\n      if (this.webhookManager && link) {\n        this.webhookManager.sendInstallmentEvent('installment.plan_suspended', plan, link).catch(err => {\n          console.error('Installment webhook error:', err);\n        });\n      }\n\n      res.json({\n        success: true,\n        plan: {\n          id: plan.id,\n          status: plan.status,\n          suspendedAt: plan.suspendedAt?.toISOString(),\n        },\n      });\n    } catch (error) {\n      res.status(400).json({ error: (error as Error).message });\n    }\n  }\n\n  private async apiCancelInstallmentPlan(req: Request, res: Response): Promise<void> {\n    try {\n      const { reason } = req.body;\n\n      const plan = await this.installmentManager.cancelPlan(req.params.id, reason);\n      const link = await this.storage.getPayLink(plan.payLinkId);\n\n      // Send webhook\n      if (this.webhookManager && link) {\n        this.webhookManager.sendInstallmentEvent('installment.plan_cancelled', plan, link).catch(err => {\n          console.error('Installment webhook error:', err);\n        });\n      }\n\n      res.json({\n        success: true,\n        plan: {\n          id: plan.id,\n          status: plan.status,\n          cancelledAt: plan.cancelledAt?.toISOString(),\n        },\n      });\n    } catch (error) {\n      res.status(400).json({ error: (error as Error).message });\n    }\n  }\n\n  private async apiGetBuyerInstallments(req: Request, res: Response): Promise<void> {\n    try {\n      const plans = await this.storage.getInstallmentPlansByBuyer(req.params.address);\n\n      res.json({\n        address: req.params.address,\n        count: plans.length,\n        plans: plans.map(p => ({\n          id: p.id,\n          payLinkId: p.payLinkId,\n          status: p.status,\n          totalAmount: p.totalAmount,\n          paidAmount: p.paidAmount,\n          totalInstallments: p.totalInstallments,\n          completedInstallments: p.completedInstallments,\n          nextDueDate: p.nextDueDate.toISOString(),\n          progress: getInstallmentProgress(p),\n        })),\n      });\n    } catch (error) {\n      console.error('Get buyer installments error:', error);\n      res.status(500).json({ error: 'Internal server error' });\n    }\n  }\n\n  private async apiGetOverdueInstallments(req: Request, res: Response): Promise<void> {\n    try {\n      const plans = await this.installmentManager.getOverduePlans();\n\n      res.json({\n        count: plans.length,\n        plans: plans.map(p => ({\n          id: p.id,\n          payLinkId: p.payLinkId,\n          buyerAddress: p.buyerAddress,\n          status: p.status,\n          totalAmount: p.totalAmount,\n          paidAmount: p.paidAmount,\n          completedInstallments: p.completedInstallments,\n          nextDueDate: p.nextDueDate.toISOString(),\n          nextInstallmentNumber: p.nextInstallmentNumber,\n          progress: getInstallmentProgress(p),\n        })),\n      });\n    } catch (error) {\n      console.error('Get overdue installments error:', error);\n      res.status(500).json({ error: 'Internal server error' });\n    }\n  }\n\n  // ========================================\n  // RESPONSE HELPERS\n  // ========================================\n\n  private send402(res: Response, link: PayLink, subscription?: Subscription): void {\n    const base = this.config.baseUrl || `http://localhost:${this.config.port}`;\n    const nonce = generateNonce();\n\n    const body: Protocol402Response = {\n      protocol: '402-paylink-v1',\n      payLinkId: link.id,\n      resource: {\n        description: link.description,\n        preview: null,\n      },\n      payment: {\n        chainId: link.price.chainId,\n        tokenSymbol: link.price.tokenSymbol,\n        amount: link.price.amount,\n        recipient: link.recipientAddress,\n        timeoutSeconds: this.config.paymentTimeout,\n      },\n      callbacks: {\n        status: `${base}${this.config.basePath}/${link.id}/status`,\n        confirm: `${base}${this.config.basePath}/${link.id}/confirm`,\n      },\n      nonce,\n    };\n\n    // Add multi-currency payment options\n    if (link.paymentOptions && link.paymentOptions.length > 0) {\n      body.paymentOptions = link.paymentOptions.map(opt => ({\n        chainId: opt.chainId,\n        tokenSymbol: opt.tokenSymbol,\n        amount: opt.amount,\n        recipient: opt.recipientAddress || link.recipientAddress,\n      }));\n    }\n\n    // Add subscription info if this is a subscription link\n    if (link.subscription) {\n      body.subscription = {\n        interval: link.subscription.interval,\n        intervalCount: link.subscription.intervalCount ?? 1,\n        trialDays: link.subscription.trialDays,\n        existingSubscriptionId: subscription?.id,\n        subscriptionStatus: subscription?.status,\n        nextPaymentDue: subscription?.nextPaymentDue.toISOString(),\n      };\n    }\n\n    if (this.config.signatureSecret) {\n      const data = JSON.stringify({ payLinkId: body.payLinkId, payment: body.payment, nonce });\n      body.signature = sign(data, this.config.signatureSecret);\n    }\n\n    res.set({\n      'Content-Type': 'application/json; charset=utf-8',\n      'X-Paylink-Protocol': '402-v1',\n    });\n    res.status(402).json(body);\n  }\n\n  private send403(\n    res: Response,\n    code: ReasonCode,\n    payLinkId?: string,\n    details?: Record<string, unknown>\n  ): void {\n    const body: Protocol403Response = {\n      protocol: '403-paylink-v1',\n      payLinkId,\n      reasonCode: code,\n      reasonMessage: REASON_MESSAGES[code] ?? 'Forbidden',\n      details,\n    };\n\n    res.set({\n      'Content-Type': 'application/json; charset=utf-8',\n      'X-Paylink-Protocol': '403-v1',\n    });\n    res.status(403).json(body);\n  }\n}\n\n/**\n * Create and start a paylink server\n */\nexport function createServer(config: PaylinkConfig): PaylinkServer {\n  return new PaylinkServer(config);\n}\n","/**\n * Payment link status\n */\nexport type PayLinkStatus = 'active' | 'disabled' | 'expired';\n\n/**\n * Referral status\n */\nexport type ReferralStatus = 'pending' | 'confirmed' | 'paid' | 'expired';\n\n/**\n * Installment plan status\n */\nexport type InstallmentStatus = 'pending' | 'active' | 'suspended' | 'completed' | 'cancelled';\n\n/**\n * Installment payment status\n */\nexport type InstallmentPaymentStatus = 'pending' | 'confirmed' | 'failed';\n\n/**\n * Payment verification status\n */\nexport type PaymentStatus = 'not_found' | 'pending' | 'confirmed' | 'failed' | 'underpaid';\n\n/**\n * Subscription interval\n */\nexport type SubscriptionInterval = 'daily' | 'weekly' | 'monthly' | 'yearly';\n\n/**\n * Subscription status\n */\nexport type SubscriptionStatus = 'active' | 'past_due' | 'cancelled' | 'paused' | 'expired';\n\n/**\n * Chain type\n */\nexport type ChainType = 'evm' | 'solana';\n\n/**\n * Supported chain configuration\n */\nexport interface ChainConfig {\n  chainId: number;\n  name: string;\n  rpcUrl: string;\n  symbol: string;\n  confirmations?: number;\n  /** Chain type (default: 'evm') */\n  type?: ChainType;\n}\n\n/**\n * Solana chain IDs\n * 101 = Mainnet, 102 = Devnet, 103 = Testnet\n */\nexport const SOLANA_CHAIN_IDS = {\n  MAINNET: 101,\n  DEVNET: 102,\n  TESTNET: 103,\n} as const;\n\n/**\n * Price configuration (single currency - legacy)\n */\nexport interface Price {\n  amount: string;\n  tokenSymbol: string;\n  chainId: number;\n}\n\n/**\n * Payment option for multi-currency support\n */\nexport interface PaymentOption {\n  /** Token symbol (e.g., ETH, SOL, USDC) */\n  tokenSymbol: string;\n  /** Chain ID where payment is accepted */\n  chainId: number;\n  /** Amount in this token */\n  amount: string;\n  /** Recipient address for this payment option (optional, uses default if not set) */\n  recipientAddress?: string;\n}\n\n/**\n * Multi-currency price configuration\n */\nexport interface MultiPrice {\n  /** Default/primary price (used for display) */\n  primary: Price;\n  /** Additional accepted payment options */\n  options: PaymentOption[];\n}\n\n/**\n * Payment link entity\n */\nexport interface PayLink {\n  id: string;\n  targetUrl: string;\n  /** Primary price (for backward compatibility) */\n  price: Price;\n  /** Additional payment options for multi-currency */\n  paymentOptions?: PaymentOption[];\n  /** Default recipient address */\n  recipientAddress: string;\n  status: PayLinkStatus;\n  createdAt: Date;\n  updatedAt: Date;\n  description?: string;\n  /** Maximum total uses (for single-use links) */\n  maxUses?: number;\n  usedCount?: number;\n  expiresAt?: Date;\n  metadata?: Record<string, unknown>;\n  /** Subscription configuration */\n  subscription?: SubscriptionConfig;\n  /** \n   * Multi-use mode: allows multiple users to pay for access\n   * Each payer gets their own access after payment\n   * When true, link doesn't expire after first payment\n   */\n  multiUse?: boolean;\n  /** Referral program configuration */\n  referral?: ReferralConfig;\n  /** Installment payment configuration */\n  installment?: InstallmentConfig;\n}\n\n/**\n * Subscription configuration for a payment link\n */\nexport interface SubscriptionConfig {\n  /** Billing interval */\n  interval: SubscriptionInterval;\n  /** Number of intervals between billings (default: 1) */\n  intervalCount?: number;\n  /** Grace period in hours after due date before marking as past_due (default: 24) */\n  gracePeriodHours?: number;\n  /** Maximum number of billing cycles (undefined = unlimited) */\n  maxCycles?: number;\n  /** Trial period in days (0 = no trial) */\n  trialDays?: number;\n}\n\n/**\n * Subscription entity\n */\nexport interface Subscription {\n  id: string;\n  payLinkId: string;\n  subscriberAddress: string;\n  status: SubscriptionStatus;\n  currentPeriodStart: Date;\n  currentPeriodEnd: Date;\n  nextPaymentDue: Date;\n  cycleCount: number;\n  lastPaymentId?: string;\n  createdAt: Date;\n  updatedAt: Date;\n  cancelledAt?: Date;\n  pausedAt?: Date;\n  trialEndsAt?: Date;\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Payment record\n */\nexport interface Payment {\n  id: string;\n  payLinkId: string;\n  chainId: number;\n  txHash: string;\n  fromAddress: string;\n  /** Amount paid */\n  amount: string;\n  /** Token symbol used for payment */\n  tokenSymbol?: string;\n  confirmed: boolean;\n  createdAt: Date;\n  confirmedAt?: Date;\n  /** Referral code used for this payment */\n  referralCode?: string;\n}\n\n/**\n * Referral configuration for a payment link\n */\nexport interface ReferralConfig {\n  /** Enable referral program for this link */\n  enabled: boolean;\n  /** Commission percentage for referrer (0-100, default: 10) */\n  commissionPercent: number;\n  /** Minimum payout threshold (optional) */\n  minPayoutThreshold?: string;\n  /** Commission expires after N days (optional) */\n  expirationDays?: number;\n}\n\n/**\n * Referral entity\n */\nexport interface Referral {\n  /** Unique referral ID */\n  id: string;\n  /** Referral code (short, shareable) */\n  code: string;\n  /** Referrer wallet address (who earns commission) */\n  referrerAddress: string;\n  /** Associated PayLink ID */\n  payLinkId: string;\n  /** Total referrals count */\n  totalReferrals: number;\n  /** Confirmed referrals count */\n  confirmedReferrals: number;\n  /** Total commission earned (in primary token) */\n  totalEarned: string;\n  /** Pending commission (not yet paid out) */\n  pendingAmount: string;\n  /** Paid out commission */\n  paidAmount: string;\n  /** Status */\n  status: 'active' | 'disabled';\n  /** Created timestamp */\n  createdAt: Date;\n  /** Updated timestamp */\n  updatedAt: Date;\n  /** Custom metadata */\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Referral commission record (individual commission per payment)\n */\nexport interface ReferralCommission {\n  /** Unique commission ID */\n  id: string;\n  /** Referral ID */\n  referralId: string;\n  /** Payment ID that triggered this commission */\n  paymentId: string;\n  /** PayLink ID */\n  payLinkId: string;\n  /** Referrer address */\n  referrerAddress: string;\n  /** Referred user address */\n  referredAddress: string;\n  /** Payment amount */\n  paymentAmount: string;\n  /** Commission amount */\n  commissionAmount: string;\n  /** Commission percentage at time of payment */\n  commissionPercent: number;\n  /** Token symbol */\n  tokenSymbol: string;\n  /** Chain ID */\n  chainId: number;\n  /** Status */\n  status: ReferralStatus;\n  /** Created timestamp */\n  createdAt: Date;\n  /** Confirmed timestamp */\n  confirmedAt?: Date;\n  /** Paid out timestamp */\n  paidAt?: Date;\n  /** Payout transaction hash */\n  payoutTxHash?: string;\n}\n\n/**\n * Input for creating a referral\n */\nexport interface CreateReferralInput {\n  /** PayLink ID */\n  payLinkId: string;\n  /** Referrer wallet address */\n  referrerAddress: string;\n  /** Custom referral code (optional, auto-generated if not provided) */\n  code?: string;\n  /** Custom metadata */\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Referral statistics\n */\nexport interface ReferralStats {\n  /** Total referrals */\n  totalReferrals: number;\n  /** Confirmed referrals */\n  confirmedReferrals: number;\n  /** Pending referrals */\n  pendingReferrals: number;\n  /** Total earned */\n  totalEarned: string;\n  /** Pending payout */\n  pendingPayout: string;\n  /** Paid out */\n  paidOut: string;\n  /** Conversion rate (confirmed / total) */\n  conversionRate: number;\n}\n\n/**\n * Installment configuration for a payment link\n */\nexport interface InstallmentConfig {\n  /** Enable installment payments for this link */\n  enabled: boolean;\n  /** Total number of installments (default: 4) */\n  totalInstallments?: number;\n  /** Days between installments (default: 30) */\n  intervalDays?: number;\n  /** First payment percentage (0-100, default: 25) */\n  downPaymentPercent?: number;\n  /** Grace period in days before suspending access (default: 3) */\n  gracePeriodDays?: number;\n  /** Automatically suspend access on missed payment (default: true) */\n  autoSuspend?: boolean;\n}\n\n/**\n * Installment plan entity\n */\nexport interface InstallmentPlan {\n  /** Unique plan ID */\n  id: string;\n  /** Associated PayLink ID */\n  payLinkId: string;\n  /** Buyer wallet address */\n  buyerAddress: string;\n  /** Plan status */\n  status: InstallmentStatus;\n  /** Total amount to be paid */\n  totalAmount: string;\n  /** Amount paid so far */\n  paidAmount: string;\n  /** Total number of installments */\n  totalInstallments: number;\n  /** Number of completed installments */\n  completedInstallments: number;\n  /** Amount for each installment */\n  installmentAmounts: string[];\n  /** Days between payments */\n  intervalDays: number;\n  /** Grace period days */\n  gracePeriodDays: number;\n  /** Next payment due date */\n  nextDueDate: Date;\n  /** Next installment number (1-based) */\n  nextInstallmentNumber: number;\n  /** Created timestamp */\n  createdAt: Date;\n  /** Updated timestamp */\n  updatedAt: Date;\n  /** When first payment was made (access granted) */\n  activatedAt?: Date;\n  /** When all payments completed */\n  completedAt?: Date;\n  /** When plan was suspended */\n  suspendedAt?: Date;\n  /** When plan was cancelled */\n  cancelledAt?: Date;\n  /** Custom metadata */\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Individual installment payment record\n */\nexport interface InstallmentPayment {\n  /** Unique payment ID */\n  id: string;\n  /** Installment plan ID */\n  installmentPlanId: string;\n  /** Original payment ID (from Payment entity) */\n  paymentId: string;\n  /** PayLink ID */\n  payLinkId: string;\n  /** Buyer address */\n  buyerAddress: string;\n  /** Installment number (1-based) */\n  installmentNumber: number;\n  /** Actual amount paid */\n  amount: string;\n  /** Expected amount for this installment */\n  expectedAmount: string;\n  /** Transaction hash */\n  txHash: string;\n  /** Chain ID */\n  chainId: number;\n  /** Token symbol */\n  tokenSymbol: string;\n  /** Payment status */\n  status: InstallmentPaymentStatus;\n  /** Due date for this installment */\n  dueDate: Date;\n  /** Created timestamp */\n  createdAt: Date;\n  /** Confirmed timestamp */\n  confirmedAt?: Date;\n}\n\n/**\n * Input for creating an installment plan\n */\nexport interface CreateInstallmentPlanInput {\n  /** PayLink ID */\n  payLinkId: string;\n  /** Buyer wallet address */\n  buyerAddress: string;\n  /** Custom metadata */\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Installment plan statistics\n */\nexport interface InstallmentPlanStats {\n  /** Total plans */\n  totalPlans: number;\n  /** Active plans */\n  activePlans: number;\n  /** Completed plans */\n  completedPlans: number;\n  /** Suspended plans */\n  suspendedPlans: number;\n  /** Total amount collected */\n  totalCollected: string;\n  /** Total amount pending */\n  totalPending: string;\n}\n\n/**\n * Input for creating a payment link\n */\nexport interface CreatePayLinkInput {\n  targetUrl: string;\n  /** Primary price */\n  price: Price;\n  /** Additional payment options for multi-currency */\n  paymentOptions?: PaymentOption[];\n  /** Default recipient address */\n  recipientAddress: string;\n  description?: string;\n  /** Maximum total uses (optional limit even for multi-use links) */\n  maxUses?: number;\n  expiresAt?: Date;\n  metadata?: Record<string, unknown>;\n  /** Subscription configuration (if set, creates a subscription link) */\n  subscription?: SubscriptionConfig;\n  /** \n   * Multi-use mode: allows multiple users to pay for access\n   * Each payer gets their own access after payment\n   */\n  multiUse?: boolean;\n  /** Referral program configuration */\n  referral?: ReferralConfig;\n  /** Installment payment configuration */\n  installment?: InstallmentConfig;\n}\n\n/**\n * Input for creating a subscription\n */\nexport interface CreateSubscriptionInput {\n  payLinkId: string;\n  subscriberAddress: string;\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * 402 Protocol response\n */\nexport interface Protocol402Response {\n  protocol: '402-paylink-v1';\n  payLinkId: string;\n  resource: {\n    description?: string;\n    preview?: string | null;\n  };\n  /** Primary payment option */\n  payment: {\n    chainId: number;\n    tokenSymbol: string;\n    amount: string;\n    recipient: string;\n    timeoutSeconds: number;\n  };\n  /** Additional payment options (multi-currency) */\n  paymentOptions?: Array<{\n    chainId: number;\n    tokenSymbol: string;\n    amount: string;\n    recipient: string;\n  }>;\n  callbacks: {\n    status: string;\n    confirm: string;\n  };\n  nonce: string;\n  signature?: string;\n  /** Subscription info (if this is a subscription link) */\n  subscription?: {\n    interval: SubscriptionInterval;\n    intervalCount: number;\n    trialDays?: number;\n    /** Existing subscription ID if subscriber already has one */\n    existingSubscriptionId?: string;\n    /** Current subscription status */\n    subscriptionStatus?: SubscriptionStatus;\n    /** Next payment due date */\n    nextPaymentDue?: string;\n  };\n}\n\n/**\n * 403 Reason codes\n */\nexport enum ReasonCode {\n  LINK_NOT_FOUND = 'LINK_NOT_FOUND',\n  LINK_DISABLED = 'LINK_DISABLED',\n  LINK_EXPIRED = 'LINK_EXPIRED',\n  LINK_USAGE_LIMIT_REACHED = 'LINK_USAGE_LIMIT_REACHED',\n  PAYMENT_UNDERPAID = 'PAYMENT_UNDERPAID',\n  PAYMENT_CHAIN_NOT_SUPPORTED = 'PAYMENT_CHAIN_NOT_SUPPORTED',\n  ACCESS_DENIED = 'ACCESS_DENIED',\n  INTERNAL_ERROR = 'INTERNAL_ERROR',\n  SUBSCRIPTION_CANCELLED = 'SUBSCRIPTION_CANCELLED',\n  SUBSCRIPTION_PAST_DUE = 'SUBSCRIPTION_PAST_DUE',\n  SUBSCRIPTION_PAUSED = 'SUBSCRIPTION_PAUSED',\n  SUBSCRIPTION_EXPIRED = 'SUBSCRIPTION_EXPIRED',\n  SUBSCRIPTION_MAX_CYCLES_REACHED = 'SUBSCRIPTION_MAX_CYCLES_REACHED',\n}\n\n/**\n * 403 Protocol response\n */\nexport interface Protocol403Response {\n  protocol: '403-paylink-v1';\n  payLinkId?: string;\n  reasonCode: ReasonCode;\n  reasonMessage: string;\n  details?: Record<string, unknown>;\n}\n\n/**\n * Webhook configuration\n */\nexport interface WebhookConfigType {\n  /** Webhook URL to send events to */\n  url: string;\n  /** Secret for HMAC signature */\n  secret?: string;\n  /** Events to send */\n  events?: Array<\n    | 'payment.confirmed'\n    | 'payment.pending'\n    | 'payment.failed'\n    | 'payment.underpaid'\n    | 'link.created'\n    | 'link.disabled'\n    | 'subscription.created'\n    | 'subscription.renewed'\n    | 'subscription.cancelled'\n    | 'subscription.paused'\n    | 'subscription.resumed'\n    | 'subscription.past_due'\n    | 'subscription.expired'\n    | 'subscription.trial_ending'\n    | 'subscription.payment_due'\n  >;\n  /** Request timeout in ms */\n  timeout?: number;\n  /** Retry count on failure */\n  retries?: number;\n}\n\n/**\n * PAYLINK token configuration\n */\nexport interface PaylinkTokenConfigType {\n  /** Enable PAYLINK token payments */\n  enabled?: boolean;\n  /** Discount when paying with PAYLINK token (percentage, 0-100) */\n  paymentDiscount?: number;\n  /** Enable holder discounts based on PAYLINK balance */\n  holderDiscounts?: boolean;\n  /** Custom discount tiers */\n  discountTiers?: Array<{\n    minBalance: number;\n    discountPercent: number;\n    name: string;\n  }>;\n}\n\n/**\n * Server configuration\n */\nexport interface PaylinkConfig {\n  /** Server port */\n  port?: number;\n  /** Base URL for callbacks (e.g., https://your-domain.com) */\n  baseUrl?: string;\n  /** Base path for paylink routes (default: /pay) */\n  basePath?: string;\n  /** Supported blockchain networks */\n  chains: ChainConfig[];\n  /** Payment timeout in seconds (default: 900) */\n  paymentTimeout?: number;\n  /** Secret for signing responses */\n  signatureSecret?: string;\n  /** API key for admin endpoints */\n  apiKey?: string;\n  /** Enable CORS (default: true) */\n  cors?: boolean;\n  /** Webhook configuration */\n  webhook?: WebhookConfigType;\n  /** PAYLINK token configuration */\n  paylinkToken?: PaylinkTokenConfigType;\n}\n\n/**\n * Payment check result\n */\nexport interface PaymentCheckResult {\n  status: PaymentStatus;\n  actualAmount?: string;\n  fromAddress?: string;\n  raw?: unknown;\n}\n\n/**\n * Storage interface\n */\nexport interface Storage {\n  getPayLink(id: string): Promise<PayLink | null>;\n  savePayLink(payLink: PayLink): Promise<void>;\n  updatePayLink(payLink: PayLink): Promise<void>;\n  deletePayLink(id: string): Promise<void>;\n  getAllPayLinks(): Promise<PayLink[]>;\n  \n  savePayment(payment: Payment): Promise<void>;\n  getPaymentByTxHash(txHash: string): Promise<Payment | null>;\n  getConfirmedPayment(payLinkId: string): Promise<Payment | null>;\n  /** Get confirmed payment for a specific payer address on a link */\n  getConfirmedPaymentByAddress(payLinkId: string, fromAddress: string): Promise<Payment | null>;\n  /** Get all payments for a link */\n  getPaymentsByLink(payLinkId: string): Promise<Payment[]>;\n  getAllPayments(): Promise<Payment[]>;\n\n  // Subscription methods\n  saveSubscription(subscription: Subscription): Promise<void>;\n  getSubscription(id: string): Promise<Subscription | null>;\n  updateSubscription(subscription: Subscription): Promise<void>;\n  getSubscriptionByAddress(payLinkId: string, subscriberAddress: string): Promise<Subscription | null>;\n  getSubscriptionsByPayLink(payLinkId: string): Promise<Subscription[]>;\n  getSubscriptionsDue(beforeDate: Date): Promise<Subscription[]>;\n  getAllSubscriptions(): Promise<Subscription[]>;\n\n  // Referral methods\n  saveReferral(referral: Referral): Promise<void>;\n  getReferral(id: string): Promise<Referral | null>;\n  getReferralByCode(code: string): Promise<Referral | null>;\n  updateReferral(referral: Referral): Promise<void>;\n  getReferralsByPayLink(payLinkId: string): Promise<Referral[]>;\n  getReferralsByReferrer(referrerAddress: string): Promise<Referral[]>;\n  getAllReferrals(): Promise<Referral[]>;\n\n  // Referral commission methods\n  saveCommission(commission: ReferralCommission): Promise<void>;\n  getCommission(id: string): Promise<ReferralCommission | null>;\n  updateCommission(commission: ReferralCommission): Promise<void>;\n  getCommissionsByReferral(referralId: string): Promise<ReferralCommission[]>;\n  getCommissionsByReferrer(referrerAddress: string): Promise<ReferralCommission[]>;\n  getPendingCommissions(referrerAddress: string): Promise<ReferralCommission[]>;\n  getAllCommissions(): Promise<ReferralCommission[]>;\n\n  // Installment plan methods\n  saveInstallmentPlan(plan: InstallmentPlan): Promise<void>;\n  getInstallmentPlan(id: string): Promise<InstallmentPlan | null>;\n  updateInstallmentPlan(plan: InstallmentPlan): Promise<void>;\n  getInstallmentPlanByAddress(payLinkId: string, buyerAddress: string): Promise<InstallmentPlan | null>;\n  getInstallmentPlansByPayLink(payLinkId: string): Promise<InstallmentPlan[]>;\n  getInstallmentPlansByBuyer(buyerAddress: string): Promise<InstallmentPlan[]>;\n  getOverdueInstallmentPlans(): Promise<InstallmentPlan[]>;\n  getInstallmentPlansDueBefore(date: Date): Promise<InstallmentPlan[]>;\n  getAllInstallmentPlans(): Promise<InstallmentPlan[]>;\n\n  // Installment payment methods\n  saveInstallmentPayment(payment: InstallmentPayment): Promise<void>;\n  getInstallmentPayment(id: string): Promise<InstallmentPayment | null>;\n  updateInstallmentPayment(payment: InstallmentPayment): Promise<void>;\n  getInstallmentPaymentsByPlan(planId: string): Promise<InstallmentPayment[]>;\n  getInstallmentPaymentsByBuyer(buyerAddress: string): Promise<InstallmentPayment[]>;\n  getAllInstallmentPayments(): Promise<InstallmentPayment[]>;\n}\n","import type { Storage, PayLink, Payment, Subscription, Referral, ReferralCommission, InstallmentPlan, InstallmentPayment } from './types.js';\n\n/**\n * In-memory storage implementation\n * Replace with database for production\n */\nexport class MemoryStorage implements Storage {\n  private links = new Map<string, PayLink>();\n  private payments = new Map<string, Payment>();\n  private paymentsByTx = new Map<string, Payment>();\n  private paymentsByLink = new Map<string, Payment[]>();\n  private paymentsByAddress = new Map<string, Payment>();\n  private subscriptions = new Map<string, Subscription>();\n  private subscriptionsByAddress = new Map<string, Subscription>();\n  private subscriptionsByLink = new Map<string, Subscription[]>();\n  private referrals = new Map<string, Referral>();\n  private referralsByCode = new Map<string, Referral>();\n  private referralsByLink = new Map<string, Referral[]>();\n  private referralsByReferrer = new Map<string, Referral[]>();\n  private commissions = new Map<string, ReferralCommission>();\n  private commissionsByReferral = new Map<string, ReferralCommission[]>();\n  private commissionsByReferrer = new Map<string, ReferralCommission[]>();\n  private installmentPlans = new Map<string, InstallmentPlan>();\n  private installmentPlansByAddress = new Map<string, InstallmentPlan>();\n  private installmentPlansByLink = new Map<string, InstallmentPlan[]>();\n  private installmentPlansByBuyer = new Map<string, InstallmentPlan[]>();\n  private installmentPayments = new Map<string, InstallmentPayment>();\n  private installmentPaymentsByPlan = new Map<string, InstallmentPayment[]>();\n  private installmentPaymentsByBuyer = new Map<string, InstallmentPayment[]>();\n\n  async getPayLink(id: string): Promise<PayLink | null> {\n    return this.links.get(id) ?? null;\n  }\n\n  async savePayLink(payLink: PayLink): Promise<void> {\n    this.links.set(payLink.id, { ...payLink });\n  }\n\n  async updatePayLink(payLink: PayLink): Promise<void> {\n    if (!this.links.has(payLink.id)) {\n      throw new Error(`PayLink ${payLink.id} not found`);\n    }\n    this.links.set(payLink.id, { ...payLink, updatedAt: new Date() });\n  }\n\n  async deletePayLink(id: string): Promise<void> {\n    this.links.delete(id);\n  }\n\n  async getAllPayLinks(): Promise<PayLink[]> {\n    return Array.from(this.links.values());\n  }\n\n  async savePayment(payment: Payment): Promise<void> {\n    this.payments.set(payment.id, { ...payment });\n    this.paymentsByTx.set(payment.txHash, payment);\n    \n    // Index by link\n    const list = this.paymentsByLink.get(payment.payLinkId) ?? [];\n    list.push(payment);\n    this.paymentsByLink.set(payment.payLinkId, list);\n    \n    // Index by address (for multi-use links)\n    if (payment.fromAddress) {\n      const addressKey = `${payment.payLinkId}:${payment.fromAddress.toLowerCase()}`;\n      this.paymentsByAddress.set(addressKey, payment);\n    }\n  }\n\n  async getPaymentByTxHash(txHash: string): Promise<Payment | null> {\n    return this.paymentsByTx.get(txHash) ?? null;\n  }\n\n  async getConfirmedPayment(payLinkId: string): Promise<Payment | null> {\n    const list = this.paymentsByLink.get(payLinkId) ?? [];\n    return list.find(p => p.confirmed) ?? null;\n  }\n\n  async getConfirmedPaymentByAddress(\n    payLinkId: string,\n    fromAddress: string\n  ): Promise<Payment | null> {\n    const addressKey = `${payLinkId}:${fromAddress.toLowerCase()}`;\n    const payment = this.paymentsByAddress.get(addressKey);\n    if (payment && payment.confirmed) {\n      return payment;\n    }\n    return null;\n  }\n\n  async getPaymentsByLink(payLinkId: string): Promise<Payment[]> {\n    return this.paymentsByLink.get(payLinkId) ?? [];\n  }\n\n  async getAllPayments(): Promise<Payment[]> {\n    return Array.from(this.payments.values());\n  }\n\n  // Subscription methods\n\n  async saveSubscription(subscription: Subscription): Promise<void> {\n    this.subscriptions.set(subscription.id, { ...subscription });\n    \n    // Index by address\n    const addressKey = `${subscription.payLinkId}:${subscription.subscriberAddress}`;\n    this.subscriptionsByAddress.set(addressKey, subscription);\n    \n    // Index by link\n    const linkSubs = this.subscriptionsByLink.get(subscription.payLinkId) ?? [];\n    linkSubs.push(subscription);\n    this.subscriptionsByLink.set(subscription.payLinkId, linkSubs);\n  }\n\n  async getSubscription(id: string): Promise<Subscription | null> {\n    return this.subscriptions.get(id) ?? null;\n  }\n\n  async updateSubscription(subscription: Subscription): Promise<void> {\n    if (!this.subscriptions.has(subscription.id)) {\n      throw new Error(`Subscription ${subscription.id} not found`);\n    }\n    \n    const updated = { ...subscription, updatedAt: new Date() };\n    this.subscriptions.set(subscription.id, updated);\n    \n    // Update address index\n    const addressKey = `${subscription.payLinkId}:${subscription.subscriberAddress}`;\n    this.subscriptionsByAddress.set(addressKey, updated);\n    \n    // Update link index\n    const linkSubs = this.subscriptionsByLink.get(subscription.payLinkId) ?? [];\n    const idx = linkSubs.findIndex(s => s.id === subscription.id);\n    if (idx !== -1) {\n      linkSubs[idx] = updated;\n    }\n  }\n\n  async getSubscriptionByAddress(\n    payLinkId: string,\n    subscriberAddress: string\n  ): Promise<Subscription | null> {\n    const addressKey = `${payLinkId}:${subscriberAddress}`;\n    return this.subscriptionsByAddress.get(addressKey) ?? null;\n  }\n\n  async getSubscriptionsByPayLink(payLinkId: string): Promise<Subscription[]> {\n    return this.subscriptionsByLink.get(payLinkId) ?? [];\n  }\n\n  async getSubscriptionsDue(beforeDate: Date): Promise<Subscription[]> {\n    const result: Subscription[] = [];\n    for (const sub of this.subscriptions.values()) {\n      if (\n        sub.status === 'active' &&\n        sub.nextPaymentDue <= beforeDate\n      ) {\n        result.push(sub);\n      }\n    }\n    return result;\n  }\n\n  async getAllSubscriptions(): Promise<Subscription[]> {\n    return Array.from(this.subscriptions.values());\n  }\n\n  // Referral methods\n\n  async saveReferral(referral: Referral): Promise<void> {\n    this.referrals.set(referral.id, { ...referral });\n    this.referralsByCode.set(referral.code.toUpperCase(), referral);\n\n    // Index by link\n    const linkRefs = this.referralsByLink.get(referral.payLinkId) ?? [];\n    linkRefs.push(referral);\n    this.referralsByLink.set(referral.payLinkId, linkRefs);\n\n    // Index by referrer\n    const referrerKey = referral.referrerAddress.toLowerCase();\n    const referrerRefs = this.referralsByReferrer.get(referrerKey) ?? [];\n    referrerRefs.push(referral);\n    this.referralsByReferrer.set(referrerKey, referrerRefs);\n  }\n\n  async getReferral(id: string): Promise<Referral | null> {\n    return this.referrals.get(id) ?? null;\n  }\n\n  async getReferralByCode(code: string): Promise<Referral | null> {\n    return this.referralsByCode.get(code.toUpperCase()) ?? null;\n  }\n\n  async updateReferral(referral: Referral): Promise<void> {\n    if (!this.referrals.has(referral.id)) {\n      throw new Error(`Referral ${referral.id} not found`);\n    }\n\n    const updated = { ...referral, updatedAt: new Date() };\n    this.referrals.set(referral.id, updated);\n    this.referralsByCode.set(referral.code.toUpperCase(), updated);\n\n    // Update link index\n    const linkRefs = this.referralsByLink.get(referral.payLinkId) ?? [];\n    const linkIdx = linkRefs.findIndex(r => r.id === referral.id);\n    if (linkIdx !== -1) {\n      linkRefs[linkIdx] = updated;\n    }\n\n    // Update referrer index\n    const referrerKey = referral.referrerAddress.toLowerCase();\n    const referrerRefs = this.referralsByReferrer.get(referrerKey) ?? [];\n    const referrerIdx = referrerRefs.findIndex(r => r.id === referral.id);\n    if (referrerIdx !== -1) {\n      referrerRefs[referrerIdx] = updated;\n    }\n  }\n\n  async getReferralsByPayLink(payLinkId: string): Promise<Referral[]> {\n    return this.referralsByLink.get(payLinkId) ?? [];\n  }\n\n  async getReferralsByReferrer(referrerAddress: string): Promise<Referral[]> {\n    return this.referralsByReferrer.get(referrerAddress.toLowerCase()) ?? [];\n  }\n\n  async getAllReferrals(): Promise<Referral[]> {\n    return Array.from(this.referrals.values());\n  }\n\n  // Referral commission methods\n\n  async saveCommission(commission: ReferralCommission): Promise<void> {\n    this.commissions.set(commission.id, { ...commission });\n\n    // Index by referral\n    const refComms = this.commissionsByReferral.get(commission.referralId) ?? [];\n    refComms.push(commission);\n    this.commissionsByReferral.set(commission.referralId, refComms);\n\n    // Index by referrer\n    const referrerKey = commission.referrerAddress.toLowerCase();\n    const referrerComms = this.commissionsByReferrer.get(referrerKey) ?? [];\n    referrerComms.push(commission);\n    this.commissionsByReferrer.set(referrerKey, referrerComms);\n  }\n\n  async getCommission(id: string): Promise<ReferralCommission | null> {\n    return this.commissions.get(id) ?? null;\n  }\n\n  async updateCommission(commission: ReferralCommission): Promise<void> {\n    if (!this.commissions.has(commission.id)) {\n      throw new Error(`Commission ${commission.id} not found`);\n    }\n\n    this.commissions.set(commission.id, { ...commission });\n\n    // Update referral index\n    const refComms = this.commissionsByReferral.get(commission.referralId) ?? [];\n    const refIdx = refComms.findIndex(c => c.id === commission.id);\n    if (refIdx !== -1) {\n      refComms[refIdx] = commission;\n    }\n\n    // Update referrer index\n    const referrerKey = commission.referrerAddress.toLowerCase();\n    const referrerComms = this.commissionsByReferrer.get(referrerKey) ?? [];\n    const referrerIdx = referrerComms.findIndex(c => c.id === commission.id);\n    if (referrerIdx !== -1) {\n      referrerComms[referrerIdx] = commission;\n    }\n  }\n\n  async getCommissionsByReferral(referralId: string): Promise<ReferralCommission[]> {\n    return this.commissionsByReferral.get(referralId) ?? [];\n  }\n\n  async getCommissionsByReferrer(referrerAddress: string): Promise<ReferralCommission[]> {\n    return this.commissionsByReferrer.get(referrerAddress.toLowerCase()) ?? [];\n  }\n\n  async getPendingCommissions(referrerAddress: string): Promise<ReferralCommission[]> {\n    const comms = await this.getCommissionsByReferrer(referrerAddress);\n    return comms.filter(c => c.status === 'confirmed');\n  }\n\n  async getAllCommissions(): Promise<ReferralCommission[]> {\n    return Array.from(this.commissions.values());\n  }\n\n  // Installment plan methods\n\n  async saveInstallmentPlan(plan: InstallmentPlan): Promise<void> {\n    this.installmentPlans.set(plan.id, { ...plan });\n\n    // Index by address\n    const addressKey = `${plan.payLinkId}:${plan.buyerAddress.toLowerCase()}`;\n    this.installmentPlansByAddress.set(addressKey, plan);\n\n    // Index by link\n    const linkPlans = this.installmentPlansByLink.get(plan.payLinkId) ?? [];\n    linkPlans.push(plan);\n    this.installmentPlansByLink.set(plan.payLinkId, linkPlans);\n\n    // Index by buyer\n    const buyerKey = plan.buyerAddress.toLowerCase();\n    const buyerPlans = this.installmentPlansByBuyer.get(buyerKey) ?? [];\n    buyerPlans.push(plan);\n    this.installmentPlansByBuyer.set(buyerKey, buyerPlans);\n  }\n\n  async getInstallmentPlan(id: string): Promise<InstallmentPlan | null> {\n    return this.installmentPlans.get(id) ?? null;\n  }\n\n  async updateInstallmentPlan(plan: InstallmentPlan): Promise<void> {\n    if (!this.installmentPlans.has(plan.id)) {\n      throw new Error(`Installment plan ${plan.id} not found`);\n    }\n\n    const updated = { ...plan, updatedAt: new Date() };\n    this.installmentPlans.set(plan.id, updated);\n\n    // Update address index\n    const addressKey = `${plan.payLinkId}:${plan.buyerAddress.toLowerCase()}`;\n    this.installmentPlansByAddress.set(addressKey, updated);\n\n    // Update link index\n    const linkPlans = this.installmentPlansByLink.get(plan.payLinkId) ?? [];\n    const linkIdx = linkPlans.findIndex(p => p.id === plan.id);\n    if (linkIdx !== -1) {\n      linkPlans[linkIdx] = updated;\n    }\n\n    // Update buyer index\n    const buyerKey = plan.buyerAddress.toLowerCase();\n    const buyerPlans = this.installmentPlansByBuyer.get(buyerKey) ?? [];\n    const buyerIdx = buyerPlans.findIndex(p => p.id === plan.id);\n    if (buyerIdx !== -1) {\n      buyerPlans[buyerIdx] = updated;\n    }\n  }\n\n  async getInstallmentPlanByAddress(\n    payLinkId: string,\n    buyerAddress: string\n  ): Promise<InstallmentPlan | null> {\n    const addressKey = `${payLinkId}:${buyerAddress.toLowerCase()}`;\n    return this.installmentPlansByAddress.get(addressKey) ?? null;\n  }\n\n  async getInstallmentPlansByPayLink(payLinkId: string): Promise<InstallmentPlan[]> {\n    return this.installmentPlansByLink.get(payLinkId) ?? [];\n  }\n\n  async getInstallmentPlansByBuyer(buyerAddress: string): Promise<InstallmentPlan[]> {\n    return this.installmentPlansByBuyer.get(buyerAddress.toLowerCase()) ?? [];\n  }\n\n  async getOverdueInstallmentPlans(): Promise<InstallmentPlan[]> {\n    const now = new Date();\n    const result: InstallmentPlan[] = [];\n\n    for (const plan of this.installmentPlans.values()) {\n      if (plan.status === 'active') {\n        const graceEnd = new Date(plan.nextDueDate);\n        graceEnd.setDate(graceEnd.getDate() + plan.gracePeriodDays);\n        \n        if (now > graceEnd) {\n          result.push(plan);\n        }\n      }\n    }\n\n    return result;\n  }\n\n  async getInstallmentPlansDueBefore(date: Date): Promise<InstallmentPlan[]> {\n    const result: InstallmentPlan[] = [];\n\n    for (const plan of this.installmentPlans.values()) {\n      if (\n        (plan.status === 'active' || plan.status === 'pending') &&\n        plan.nextDueDate <= date\n      ) {\n        result.push(plan);\n      }\n    }\n\n    return result;\n  }\n\n  async getAllInstallmentPlans(): Promise<InstallmentPlan[]> {\n    return Array.from(this.installmentPlans.values());\n  }\n\n  // Installment payment methods\n\n  async saveInstallmentPayment(payment: InstallmentPayment): Promise<void> {\n    this.installmentPayments.set(payment.id, { ...payment });\n\n    // Index by plan\n    const planPayments = this.installmentPaymentsByPlan.get(payment.installmentPlanId) ?? [];\n    planPayments.push(payment);\n    this.installmentPaymentsByPlan.set(payment.installmentPlanId, planPayments);\n\n    // Index by buyer\n    const buyerKey = payment.buyerAddress.toLowerCase();\n    const buyerPayments = this.installmentPaymentsByBuyer.get(buyerKey) ?? [];\n    buyerPayments.push(payment);\n    this.installmentPaymentsByBuyer.set(buyerKey, buyerPayments);\n  }\n\n  async getInstallmentPayment(id: string): Promise<InstallmentPayment | null> {\n    return this.installmentPayments.get(id) ?? null;\n  }\n\n  async updateInstallmentPayment(payment: InstallmentPayment): Promise<void> {\n    if (!this.installmentPayments.has(payment.id)) {\n      throw new Error(`Installment payment ${payment.id} not found`);\n    }\n\n    this.installmentPayments.set(payment.id, { ...payment });\n\n    // Update plan index\n    const planPayments = this.installmentPaymentsByPlan.get(payment.installmentPlanId) ?? [];\n    const planIdx = planPayments.findIndex(p => p.id === payment.id);\n    if (planIdx !== -1) {\n      planPayments[planIdx] = payment;\n    }\n\n    // Update buyer index\n    const buyerKey = payment.buyerAddress.toLowerCase();\n    const buyerPayments = this.installmentPaymentsByBuyer.get(buyerKey) ?? [];\n    const buyerIdx = buyerPayments.findIndex(p => p.id === payment.id);\n    if (buyerIdx !== -1) {\n      buyerPayments[buyerIdx] = payment;\n    }\n  }\n\n  async getInstallmentPaymentsByPlan(planId: string): Promise<InstallmentPayment[]> {\n    return this.installmentPaymentsByPlan.get(planId) ?? [];\n  }\n\n  async getInstallmentPaymentsByBuyer(buyerAddress: string): Promise<InstallmentPayment[]> {\n    return this.installmentPaymentsByBuyer.get(buyerAddress.toLowerCase()) ?? [];\n  }\n\n  async getAllInstallmentPayments(): Promise<InstallmentPayment[]> {\n    return Array.from(this.installmentPayments.values());\n  }\n\n  /** Clear all data */\n  clear(): void {\n    this.links.clear();\n    this.payments.clear();\n    this.paymentsByTx.clear();\n    this.paymentsByLink.clear();\n    this.paymentsByAddress.clear();\n    this.subscriptions.clear();\n    this.subscriptionsByAddress.clear();\n    this.subscriptionsByLink.clear();\n    this.referrals.clear();\n    this.referralsByCode.clear();\n    this.referralsByLink.clear();\n    this.referralsByReferrer.clear();\n    this.commissions.clear();\n    this.commissionsByReferral.clear();\n    this.commissionsByReferrer.clear();\n    this.installmentPlans.clear();\n    this.installmentPlansByAddress.clear();\n    this.installmentPlansByLink.clear();\n    this.installmentPlansByBuyer.clear();\n    this.installmentPayments.clear();\n    this.installmentPaymentsByPlan.clear();\n    this.installmentPaymentsByBuyer.clear();\n  }\n}\n","import { randomBytes, createHmac, randomUUID } from 'crypto';\n\n/**\n * Generate short unique ID\n */\nexport function generateId(length = 8): string {\n  const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n  const bytes = randomBytes(length);\n  let result = '';\n  for (let i = 0; i < length; i++) {\n    result += chars[bytes[i] % chars.length];\n  }\n  return result;\n}\n\n/**\n * Generate UUID\n */\nexport function generateUUID(): string {\n  return randomUUID();\n}\n\n/**\n * Generate nonce\n */\nexport function generateNonce(): string {\n  return randomBytes(16).toString('hex');\n}\n\n/**\n * Create HMAC signature\n */\nexport function sign(data: string, secret: string): string {\n  return createHmac('sha256', secret).update(data).digest('hex');\n}\n\n/**\n * Check if date is expired\n */\nexport function isExpired(date?: Date): boolean {\n  if (!date) return false;\n  return new Date() > new Date(date);\n}\n\n/**\n * Check if usage limit reached\n */\nexport function isLimitReached(used?: number, max?: number): boolean {\n  if (max === undefined) return false;\n  return (used ?? 0) >= max;\n}\n\n/**\n * Compare amounts\n */\nexport function compareAmounts(a: string, b: string): number {\n  const numA = parseFloat(a);\n  const numB = parseFloat(b);\n  if (numA < numB) return -1;\n  if (numA > numB) return 1;\n  return 0;\n}\n\n/**\n * Reason code messages\n */\nexport const REASON_MESSAGES: Record<string, string> = {\n  LINK_NOT_FOUND: 'Payment link not found.',\n  LINK_DISABLED: 'This payment link has been disabled.',\n  LINK_EXPIRED: 'This payment link has expired.',\n  LINK_USAGE_LIMIT_REACHED: 'This payment link has reached its usage limit.',\n  PAYMENT_UNDERPAID: 'Payment amount is less than required.',\n  PAYMENT_CHAIN_NOT_SUPPORTED: 'This blockchain is not supported.',\n  ACCESS_DENIED: 'Access denied.',\n  INTERNAL_ERROR: 'An internal error occurred.',\n  SUBSCRIPTION_CANCELLED: 'This subscription has been cancelled.',\n  SUBSCRIPTION_PAST_DUE: 'Subscription payment is past due.',\n  SUBSCRIPTION_PAUSED: 'This subscription is paused.',\n  SUBSCRIPTION_EXPIRED: 'This subscription has expired.',\n  SUBSCRIPTION_MAX_CYCLES_REACHED: 'Subscription has reached maximum billing cycles.',\n};\n","import type { ChainConfig, PaymentCheckResult } from './types.js';\nimport { compareAmounts } from './utils.js';\n\n/**\n * Blockchain payment verifier\n */\nexport class ChainVerifier {\n  private config: ChainConfig;\n  private requestId = 0;\n\n  constructor(config: ChainConfig) {\n    this.config = config;\n  }\n\n  get chainId(): number {\n    return this.config.chainId;\n  }\n\n  /**\n   * Verify payment on chain\n   */\n  async verifyPayment(params: {\n    txHash: string;\n    recipient: string;\n    amount: string;\n  }): Promise<PaymentCheckResult> {\n    try {\n      // Get transaction\n      const tx = await this.rpc('eth_getTransactionByHash', [params.txHash]);\n      \n      if (!tx) {\n        return { status: 'not_found' };\n      }\n\n      // Not mined yet\n      if (!tx.blockNumber) {\n        return { status: 'pending' };\n      }\n\n      // Get receipt\n      const receipt = await this.rpc('eth_getTransactionReceipt', [params.txHash]);\n      \n      if (!receipt) {\n        return { status: 'pending' };\n      }\n\n      // Failed transaction\n      if (receipt.status === '0x0') {\n        return { status: 'failed' };\n      }\n\n      // Check confirmations\n      const currentBlock = await this.rpc('eth_blockNumber', []);\n      const txBlock = parseInt(tx.blockNumber, 16);\n      const current = parseInt(currentBlock, 16);\n      const confirmations = current - txBlock;\n\n      if (confirmations < (this.config.confirmations ?? 1)) {\n        return { status: 'pending' };\n      }\n\n      // Verify recipient\n      const recipientLower = params.recipient.toLowerCase();\n      const toAddress = (tx.to || '').toLowerCase();\n      \n      if (toAddress !== recipientLower) {\n        // Check if it's a token transfer\n        if (!this.isTokenTransfer(receipt, recipientLower)) {\n          return { status: 'not_found' };\n        }\n      }\n\n      // Calculate amount\n      const valueWei = BigInt(tx.value || '0');\n      const actualAmount = this.weiToEther(valueWei);\n\n      // Check amount\n      if (compareAmounts(actualAmount, params.amount) < 0) {\n        return {\n          status: 'underpaid',\n          actualAmount,\n          fromAddress: tx.from,\n        };\n      }\n\n      return {\n        status: 'confirmed',\n        actualAmount,\n        fromAddress: tx.from,\n        raw: { tx, receipt },\n      };\n    } catch (error) {\n      console.error(`Chain ${this.config.chainId} verification error:`, error);\n      return { status: 'not_found' };\n    }\n  }\n\n  private async rpc(method: string, params: unknown[]): Promise<any> {\n    const controller = new AbortController();\n    const timeout = setTimeout(() => controller.abort(), 30000);\n\n    try {\n      const response = await fetch(this.config.rpcUrl, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          jsonrpc: '2.0',\n          id: ++this.requestId,\n          method,\n          params,\n        }),\n        signal: controller.signal,\n      });\n\n      const data = await response.json() as { error?: { message: string }; result?: unknown };\n      \n      if (data.error) {\n        throw new Error(data.error.message);\n      }\n      \n      return data.result;\n    } finally {\n      clearTimeout(timeout);\n    }\n  }\n\n  private isTokenTransfer(receipt: any, recipient: string): boolean {\n    // ERC20 Transfer event signature\n    const transferTopic = '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef';\n    \n    for (const log of receipt.logs || []) {\n      if (log.topics?.[0] === transferTopic && log.topics.length >= 3) {\n        const to = '0x' + log.topics[2].slice(26).toLowerCase();\n        if (to === recipient) {\n          return true;\n        }\n      }\n    }\n    \n    return false;\n  }\n\n  private weiToEther(wei: bigint): string {\n    return (Number(wei) / 1e18).toString();\n  }\n}\n\n/**\n * Mock verifier for development/testing\n */\nexport class MockVerifier {\n  private confirmed = new Set<string>();\n  private pending = new Set<string>();\n  private failed = new Set<string>();\n\n  chainId = 1;\n\n  markConfirmed(txHash: string): void {\n    this.confirmed.add(txHash);\n    this.pending.delete(txHash);\n    this.failed.delete(txHash);\n  }\n\n  markPending(txHash: string): void {\n    this.pending.add(txHash);\n  }\n\n  markFailed(txHash: string): void {\n    this.failed.add(txHash);\n  }\n\n  async verifyPayment(params: {\n    txHash: string;\n    recipient: string;\n    amount: string;\n  }): Promise<PaymentCheckResult> {\n    await new Promise(r => setTimeout(r, 100));\n\n    if (this.failed.has(params.txHash)) {\n      return { status: 'failed' };\n    }\n\n    if (this.pending.has(params.txHash)) {\n      return { status: 'pending' };\n    }\n\n    // Auto-confirm for testing\n    return {\n      status: 'confirmed',\n      actualAmount: params.amount,\n      fromAddress: '0x' + 'a'.repeat(40),\n    };\n  }\n}\n","import type { PaymentCheckResult } from '../types.js';\nimport { compareAmounts } from '../utils.js';\n\n/**\n * Solana chain configuration\n */\nexport interface SolanaConfig {\n  /** RPC URL (e.g., https://api.mainnet-beta.solana.com) */\n  rpcUrl: string;\n  /** Number of confirmations required (default: 1) */\n  confirmations?: number;\n  /** Request timeout in ms (default: 30000) */\n  timeout?: number;\n}\n\ninterface JsonRpcResponse<T> {\n  jsonrpc: string;\n  id: number;\n  result?: T;\n  error?: {\n    code: number;\n    message: string;\n  };\n}\n\ninterface SolanaTransaction {\n  slot: number;\n  meta: {\n    err: null | object;\n    fee: number;\n    preBalances: number[];\n    postBalances: number[];\n    status: { Ok: null } | { Err: object };\n  } | null;\n  transaction: {\n    message: {\n      accountKeys: string[];\n      instructions: Array<{\n        programIdIndex: number;\n        accounts: number[];\n        data: string;\n      }>;\n    };\n    signatures: string[];\n  };\n  blockTime: number | null;\n}\n\ninterface SignatureStatus {\n  slot: number;\n  confirmations: number | null;\n  err: null | object;\n  confirmationStatus: 'processed' | 'confirmed' | 'finalized' | null;\n}\n\n/**\n * Solana Payment Verifier\n * Verifies native SOL transfers on Solana blockchain\n */\nexport class SolanaVerifier {\n  private config: Required<SolanaConfig>;\n  private requestId = 0;\n\n  constructor(config: SolanaConfig) {\n    this.config = {\n      rpcUrl: config.rpcUrl,\n      confirmations: config.confirmations ?? 1,\n      timeout: config.timeout ?? 30000,\n    };\n  }\n\n  /**\n   * Verify a Solana payment\n   */\n  async verifyPayment(params: {\n    txHash: string;\n    recipient: string;\n    amount: string;\n  }): Promise<PaymentCheckResult> {\n    try {\n      // Get transaction details\n      const tx = await this.getTransaction(params.txHash);\n\n      if (!tx) {\n        return { status: 'not_found' };\n      }\n\n      // Check if transaction failed\n      if (tx.meta?.err) {\n        return { status: 'failed' };\n      }\n\n      // Get signature status for confirmation count\n      const status = await this.getSignatureStatus(params.txHash);\n\n      if (!status) {\n        return { status: 'pending' };\n      }\n\n      // Check confirmations\n      const confirmations = status.confirmations ?? 0;\n      const isFinalized = status.confirmationStatus === 'finalized';\n\n      if (!isFinalized && confirmations < this.config.confirmations) {\n        return { status: 'pending' };\n      }\n\n      // Parse transaction to find recipient and amount\n      const { recipient: actualRecipient, amount: actualAmount, sender } = \n        this.parseTransfer(tx, params.recipient);\n\n      if (!actualRecipient) {\n        return { status: 'not_found' };\n      }\n\n      // Verify recipient matches\n      if (actualRecipient.toLowerCase() !== params.recipient.toLowerCase()) {\n        return { status: 'not_found' };\n      }\n\n      // Compare amounts (SOL has 9 decimals)\n      if (compareAmounts(actualAmount, params.amount) < 0) {\n        return {\n          status: 'underpaid',\n          actualAmount,\n          fromAddress: sender,\n          raw: tx,\n        };\n      }\n\n      return {\n        status: 'confirmed',\n        actualAmount,\n        fromAddress: sender,\n        raw: tx,\n      };\n    } catch (error) {\n      console.error('Solana verification error:', error);\n      return { status: 'not_found' };\n    }\n  }\n\n  /**\n   * Parse a Solana transaction to extract transfer details\n   */\n  private parseTransfer(\n    tx: SolanaTransaction,\n    expectedRecipient: string\n  ): { recipient: string | null; amount: string; sender: string } {\n    const accountKeys = tx.transaction.message.accountKeys;\n    const preBalances = tx.meta?.preBalances ?? [];\n    const postBalances = tx.meta?.postBalances ?? [];\n\n    // Find the expected recipient in account keys\n    const recipientIndex = accountKeys.findIndex(\n      key => key.toLowerCase() === expectedRecipient.toLowerCase()\n    );\n\n    if (recipientIndex === -1) {\n      return { recipient: null, amount: '0', sender: '' };\n    }\n\n    // Calculate amount received (in lamports)\n    const preBalance = preBalances[recipientIndex] ?? 0;\n    const postBalance = postBalances[recipientIndex] ?? 0;\n    const lamportsReceived = postBalance - preBalance;\n\n    if (lamportsReceived <= 0) {\n      return { recipient: null, amount: '0', sender: '' };\n    }\n\n    // Convert lamports to SOL (9 decimals)\n    const solAmount = lamportsReceived / 1e9;\n\n    // First account is typically the fee payer/sender\n    const sender = accountKeys[0] ?? '';\n\n    return {\n      recipient: expectedRecipient,\n      amount: solAmount.toString(),\n      sender,\n    };\n  }\n\n  /**\n   * Get transaction details from Solana RPC\n   */\n  private async getTransaction(signature: string): Promise<SolanaTransaction | null> {\n    return this.rpc<SolanaTransaction>('getTransaction', [\n      signature,\n      {\n        encoding: 'json',\n        commitment: 'confirmed',\n        maxSupportedTransactionVersion: 0,\n      },\n    ]);\n  }\n\n  /**\n   * Get signature status\n   */\n  private async getSignatureStatus(signature: string): Promise<SignatureStatus | null> {\n    const result = await this.rpc<{ value: Array<SignatureStatus | null> }>(\n      'getSignatureStatuses',\n      [[signature]]\n    );\n    return result?.value?.[0] ?? null;\n  }\n\n  /**\n   * Make an RPC call to Solana\n   */\n  private async rpc<T>(method: string, params: unknown[]): Promise<T | null> {\n    const controller = new AbortController();\n    const timeout = setTimeout(() => controller.abort(), this.config.timeout);\n\n    try {\n      const response = await fetch(this.config.rpcUrl, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          jsonrpc: '2.0',\n          id: ++this.requestId,\n          method,\n          params,\n        }),\n        signal: controller.signal,\n      });\n\n      const data = (await response.json()) as JsonRpcResponse<T>;\n\n      if (data.error) {\n        console.error('Solana RPC error:', data.error);\n        return null;\n      }\n\n      return data.result ?? null;\n    } catch (error) {\n      if ((error as Error).name === 'AbortError') {\n        console.error('Solana RPC request timeout');\n      } else {\n        console.error('Solana RPC error:', error);\n      }\n      return null;\n    } finally {\n      clearTimeout(timeout);\n    }\n  }\n}\n\n/**\n * Mock Solana verifier for testing\n */\nexport class MockSolanaVerifier {\n  private confirmed = new Set<string>();\n  private pending = new Set<string>();\n  private failed = new Set<string>();\n\n  markConfirmed(signature: string): void {\n    this.confirmed.add(signature);\n    this.pending.delete(signature);\n    this.failed.delete(signature);\n  }\n\n  markPending(signature: string): void {\n    this.pending.add(signature);\n  }\n\n  markFailed(signature: string): void {\n    this.failed.add(signature);\n  }\n\n  async verifyPayment(params: {\n    txHash: string;\n    recipient: string;\n    amount: string;\n  }): Promise<PaymentCheckResult> {\n    await new Promise(r => setTimeout(r, 100));\n\n    if (this.failed.has(params.txHash)) {\n      return { status: 'failed' };\n    }\n\n    if (this.pending.has(params.txHash)) {\n      return { status: 'pending' };\n    }\n\n    // Auto-confirm for testing\n    return {\n      status: 'confirmed',\n      actualAmount: params.amount,\n      fromAddress: 'So11111111111111111111111111111111111111112',\n    };\n  }\n}\n\n/**\n * Create a Solana verifier\n */\nexport function createSolanaVerifier(config: SolanaConfig): SolanaVerifier {\n  return new SolanaVerifier(config);\n}\n","import { createHmac } from 'crypto';\nimport type { PayLink, Payment, Subscription, Referral, ReferralCommission, InstallmentPlan, InstallmentPayment } from './types.js';\n\n/**\n * Webhook configuration\n */\nexport interface WebhookConfig {\n  /** Webhook URL to send events to */\n  url: string;\n  /** Secret for HMAC signature */\n  secret?: string;\n  /** Events to send (default: all) */\n  events?: WebhookEvent[];\n  /** Request timeout in ms (default: 10000) */\n  timeout?: number;\n  /** Retry count on failure (default: 3) */\n  retries?: number;\n  /** Custom headers to include */\n  headers?: Record<string, string>;\n}\n\n/**\n * Webhook event types\n */\nexport type WebhookEvent =\n  | 'payment.confirmed'\n  | 'payment.pending'\n  | 'payment.failed'\n  | 'payment.underpaid'\n  | 'link.created'\n  | 'link.disabled'\n  | 'link.expired'\n  | 'subscription.created'\n  | 'subscription.renewed'\n  | 'subscription.cancelled'\n  | 'subscription.paused'\n  | 'subscription.resumed'\n  | 'subscription.past_due'\n  | 'subscription.expired'\n  | 'subscription.trial_ending'\n  | 'subscription.payment_due'\n  | 'referral.created'\n  | 'referral.disabled'\n  | 'commission.pending'\n  | 'commission.confirmed'\n  | 'commission.paid'\n  | 'installment.plan_created'\n  | 'installment.payment_received'\n  | 'installment.payment_confirmed'\n  | 'installment.plan_activated'\n  | 'installment.plan_completed'\n  | 'installment.plan_suspended'\n  | 'installment.plan_cancelled'\n  | 'installment.payment_due'\n  | 'installment.payment_overdue';\n\n/**\n * Webhook payload base\n */\nexport interface WebhookPayload {\n  /** Event type */\n  event: WebhookEvent;\n  /** Event timestamp */\n  timestamp: string;\n  /** Unique event ID */\n  eventId: string;\n  /** Event data */\n  data: WebhookPaymentData | WebhookLinkData | WebhookSubscriptionData | WebhookReferralData | WebhookCommissionData | WebhookInstallmentData;\n}\n\n/**\n * Payment event data\n */\nexport interface WebhookPaymentData {\n  type: 'payment';\n  payment: {\n    id: string;\n    payLinkId: string;\n    chainId: number;\n    txHash: string;\n    fromAddress: string;\n    amount: string;\n    confirmed: boolean;\n    createdAt: string;\n    confirmedAt?: string;\n  };\n  payLink: {\n    id: string;\n    targetUrl: string;\n    price: {\n      amount: string;\n      tokenSymbol: string;\n      chainId: number;\n    };\n    recipientAddress: string;\n  };\n}\n\n/**\n * Link event data\n */\nexport interface WebhookLinkData {\n  type: 'link';\n  link: {\n    id: string;\n    targetUrl: string;\n    price: {\n      amount: string;\n      tokenSymbol: string;\n      chainId: number;\n    };\n    recipientAddress: string;\n    status: string;\n    createdAt: string;\n    description?: string;\n    maxUses?: number;\n    expiresAt?: string;\n  };\n}\n\n/**\n * Subscription event data\n */\nexport interface WebhookSubscriptionData {\n  type: 'subscription';\n  subscription: {\n    id: string;\n    payLinkId: string;\n    subscriberAddress: string;\n    status: string;\n    currentPeriodStart: string;\n    currentPeriodEnd: string;\n    nextPaymentDue: string;\n    cycleCount: number;\n    createdAt: string;\n    cancelledAt?: string;\n    pausedAt?: string;\n    trialEndsAt?: string;\n  };\n  payLink: {\n    id: string;\n    targetUrl: string;\n    price: {\n      amount: string;\n      tokenSymbol: string;\n      chainId: number;\n    };\n    recipientAddress: string;\n    subscription?: {\n      interval: string;\n      intervalCount?: number;\n    };\n  };\n}\n\n/**\n * Referral event data\n */\nexport interface WebhookReferralData {\n  type: 'referral';\n  referral: {\n    id: string;\n    code: string;\n    referrerAddress: string;\n    payLinkId: string;\n    totalReferrals: number;\n    confirmedReferrals: number;\n    totalEarned: string;\n    pendingAmount: string;\n    status: string;\n    createdAt: string;\n  };\n  payLink: {\n    id: string;\n    targetUrl: string;\n    price: {\n      amount: string;\n      tokenSymbol: string;\n      chainId: number;\n    };\n    recipientAddress: string;\n  };\n}\n\n/**\n * Commission event data\n */\nexport interface WebhookCommissionData {\n  type: 'commission';\n  commission: {\n    id: string;\n    referralId: string;\n    paymentId: string;\n    referrerAddress: string;\n    referredAddress: string;\n    paymentAmount: string;\n    commissionAmount: string;\n    commissionPercent: number;\n    tokenSymbol: string;\n    chainId: number;\n    status: string;\n    createdAt: string;\n    confirmedAt?: string;\n    paidAt?: string;\n    payoutTxHash?: string;\n  };\n  referral: {\n    id: string;\n    code: string;\n    referrerAddress: string;\n  };\n  payLink: {\n    id: string;\n    targetUrl: string;\n    price: {\n      amount: string;\n      tokenSymbol: string;\n      chainId: number;\n    };\n    recipientAddress: string;\n  };\n}\n\n/**\n * Installment event data\n */\nexport interface WebhookInstallmentData {\n  type: 'installment';\n  plan: {\n    id: string;\n    payLinkId: string;\n    buyerAddress: string;\n    status: string;\n    totalAmount: string;\n    paidAmount: string;\n    totalInstallments: number;\n    completedInstallments: number;\n    nextDueDate: string;\n    nextInstallmentNumber: number;\n    createdAt: string;\n    activatedAt?: string;\n    completedAt?: string;\n    suspendedAt?: string;\n    cancelledAt?: string;\n  };\n  payment?: {\n    id: string;\n    installmentNumber: number;\n    amount: string;\n    expectedAmount: string;\n    txHash: string;\n    status: string;\n    dueDate: string;\n    createdAt: string;\n    confirmedAt?: string;\n  };\n  payLink: {\n    id: string;\n    targetUrl: string;\n    price: {\n      amount: string;\n      tokenSymbol: string;\n      chainId: number;\n    };\n    recipientAddress: string;\n    installment?: {\n      totalInstallments?: number;\n      intervalDays?: number;\n      downPaymentPercent?: number;\n    };\n  };\n}\n\n/**\n * Webhook delivery result\n */\nexport interface WebhookResult {\n  success: boolean;\n  statusCode?: number;\n  error?: string;\n  attempts: number;\n  duration: number;\n}\n\n/**\n * Webhook Manager\n * Handles sending webhook notifications for payment events\n */\nexport class WebhookManager {\n  private config: Required<Omit<WebhookConfig, 'secret' | 'headers'>> & {\n    secret?: string;\n    headers?: Record<string, string>;\n  };\n  private queue: Array<{ payload: WebhookPayload; attempt: number }> = [];\n  private processing = false;\n\n  constructor(config: WebhookConfig) {\n    this.config = {\n      url: config.url,\n      secret: config.secret,\n      events: config.events ?? [\n        'payment.confirmed',\n        'payment.pending',\n        'payment.failed',\n        'payment.underpaid',\n        'link.created',\n        'link.disabled',\n        'subscription.created',\n        'subscription.renewed',\n        'subscription.cancelled',\n        'subscription.paused',\n        'subscription.resumed',\n        'subscription.past_due',\n        'subscription.expired',\n        'subscription.trial_ending',\n        'subscription.payment_due',\n        'referral.created',\n        'referral.disabled',\n        'commission.pending',\n        'commission.confirmed',\n        'commission.paid',\n        'installment.plan_created',\n        'installment.payment_received',\n        'installment.payment_confirmed',\n        'installment.plan_activated',\n        'installment.plan_completed',\n        'installment.plan_suspended',\n        'installment.plan_cancelled',\n        'installment.payment_due',\n        'installment.payment_overdue',\n      ],\n      timeout: config.timeout ?? 10000,\n      retries: config.retries ?? 3,\n      headers: config.headers,\n    };\n  }\n\n  /**\n   * Check if event type is enabled\n   */\n  isEventEnabled(event: WebhookEvent): boolean {\n    return this.config.events.includes(event);\n  }\n\n  /**\n   * Send payment event\n   */\n  async sendPaymentEvent(\n    event: WebhookEvent,\n    payment: Payment,\n    payLink: PayLink\n  ): Promise<WebhookResult | null> {\n    if (!this.isEventEnabled(event)) {\n      return null;\n    }\n\n    const payload: WebhookPayload = {\n      event,\n      timestamp: new Date().toISOString(),\n      eventId: this.generateEventId(),\n      data: {\n        type: 'payment',\n        payment: {\n          id: payment.id,\n          payLinkId: payment.payLinkId,\n          chainId: payment.chainId,\n          txHash: payment.txHash,\n          fromAddress: payment.fromAddress,\n          amount: payment.amount,\n          confirmed: payment.confirmed,\n          createdAt: payment.createdAt.toISOString(),\n          confirmedAt: payment.confirmedAt?.toISOString(),\n        },\n        payLink: {\n          id: payLink.id,\n          targetUrl: payLink.targetUrl,\n          price: payLink.price,\n          recipientAddress: payLink.recipientAddress,\n        },\n      },\n    };\n\n    return this.send(payload);\n  }\n\n  /**\n   * Send link event\n   */\n  async sendLinkEvent(\n    event: WebhookEvent,\n    payLink: PayLink\n  ): Promise<WebhookResult | null> {\n    if (!this.isEventEnabled(event)) {\n      return null;\n    }\n\n    const payload: WebhookPayload = {\n      event,\n      timestamp: new Date().toISOString(),\n      eventId: this.generateEventId(),\n      data: {\n        type: 'link',\n        link: {\n          id: payLink.id,\n          targetUrl: payLink.targetUrl,\n          price: payLink.price,\n          recipientAddress: payLink.recipientAddress,\n          status: payLink.status,\n          createdAt: payLink.createdAt.toISOString(),\n          description: payLink.description,\n          maxUses: payLink.maxUses,\n          expiresAt: payLink.expiresAt?.toISOString(),\n        },\n      },\n    };\n\n    return this.send(payload);\n  }\n\n  /**\n   * Send subscription event\n   */\n  async sendSubscriptionEvent(\n    event: WebhookEvent,\n    subscription: Subscription,\n    payLink: PayLink\n  ): Promise<WebhookResult | null> {\n    if (!this.isEventEnabled(event)) {\n      return null;\n    }\n\n    const payload: WebhookPayload = {\n      event,\n      timestamp: new Date().toISOString(),\n      eventId: this.generateEventId(),\n      data: {\n        type: 'subscription',\n        subscription: {\n          id: subscription.id,\n          payLinkId: subscription.payLinkId,\n          subscriberAddress: subscription.subscriberAddress,\n          status: subscription.status,\n          currentPeriodStart: subscription.currentPeriodStart.toISOString(),\n          currentPeriodEnd: subscription.currentPeriodEnd.toISOString(),\n          nextPaymentDue: subscription.nextPaymentDue.toISOString(),\n          cycleCount: subscription.cycleCount,\n          createdAt: subscription.createdAt.toISOString(),\n          cancelledAt: subscription.cancelledAt?.toISOString(),\n          pausedAt: subscription.pausedAt?.toISOString(),\n          trialEndsAt: subscription.trialEndsAt?.toISOString(),\n        },\n        payLink: {\n          id: payLink.id,\n          targetUrl: payLink.targetUrl,\n          price: payLink.price,\n          recipientAddress: payLink.recipientAddress,\n          subscription: payLink.subscription ? {\n            interval: payLink.subscription.interval,\n            intervalCount: payLink.subscription.intervalCount,\n          } : undefined,\n        },\n      },\n    };\n\n    return this.send(payload);\n  }\n\n  /**\n   * Send referral event\n   */\n  async sendReferralEvent(\n    event: WebhookEvent,\n    referral: Referral,\n    payLink: PayLink\n  ): Promise<WebhookResult | null> {\n    if (!this.isEventEnabled(event)) {\n      return null;\n    }\n\n    const payload: WebhookPayload = {\n      event,\n      timestamp: new Date().toISOString(),\n      eventId: this.generateEventId(),\n      data: {\n        type: 'referral',\n        referral: {\n          id: referral.id,\n          code: referral.code,\n          referrerAddress: referral.referrerAddress,\n          payLinkId: referral.payLinkId,\n          totalReferrals: referral.totalReferrals,\n          confirmedReferrals: referral.confirmedReferrals,\n          totalEarned: referral.totalEarned,\n          pendingAmount: referral.pendingAmount,\n          status: referral.status,\n          createdAt: referral.createdAt.toISOString(),\n        },\n        payLink: {\n          id: payLink.id,\n          targetUrl: payLink.targetUrl,\n          price: payLink.price,\n          recipientAddress: payLink.recipientAddress,\n        },\n      },\n    };\n\n    return this.send(payload);\n  }\n\n  /**\n   * Send commission event\n   */\n  async sendCommissionEvent(\n    event: WebhookEvent,\n    commission: ReferralCommission,\n    referral: Referral,\n    payLink: PayLink\n  ): Promise<WebhookResult | null> {\n    if (!this.isEventEnabled(event)) {\n      return null;\n    }\n\n    const payload: WebhookPayload = {\n      event,\n      timestamp: new Date().toISOString(),\n      eventId: this.generateEventId(),\n      data: {\n        type: 'commission',\n        commission: {\n          id: commission.id,\n          referralId: commission.referralId,\n          paymentId: commission.paymentId,\n          referrerAddress: commission.referrerAddress,\n          referredAddress: commission.referredAddress,\n          paymentAmount: commission.paymentAmount,\n          commissionAmount: commission.commissionAmount,\n          commissionPercent: commission.commissionPercent,\n          tokenSymbol: commission.tokenSymbol,\n          chainId: commission.chainId,\n          status: commission.status,\n          createdAt: commission.createdAt.toISOString(),\n          confirmedAt: commission.confirmedAt?.toISOString(),\n          paidAt: commission.paidAt?.toISOString(),\n          payoutTxHash: commission.payoutTxHash,\n        },\n        referral: {\n          id: referral.id,\n          code: referral.code,\n          referrerAddress: referral.referrerAddress,\n        },\n        payLink: {\n          id: payLink.id,\n          targetUrl: payLink.targetUrl,\n          price: payLink.price,\n          recipientAddress: payLink.recipientAddress,\n        },\n      },\n    };\n\n    return this.send(payload);\n  }\n\n  /**\n   * Send installment event\n   */\n  async sendInstallmentEvent(\n    event: WebhookEvent,\n    plan: InstallmentPlan,\n    payLink: PayLink,\n    payment?: InstallmentPayment\n  ): Promise<WebhookResult | null> {\n    if (!this.isEventEnabled(event)) {\n      return null;\n    }\n\n    const payload: WebhookPayload = {\n      event,\n      timestamp: new Date().toISOString(),\n      eventId: this.generateEventId(),\n      data: {\n        type: 'installment',\n        plan: {\n          id: plan.id,\n          payLinkId: plan.payLinkId,\n          buyerAddress: plan.buyerAddress,\n          status: plan.status,\n          totalAmount: plan.totalAmount,\n          paidAmount: plan.paidAmount,\n          totalInstallments: plan.totalInstallments,\n          completedInstallments: plan.completedInstallments,\n          nextDueDate: plan.nextDueDate.toISOString(),\n          nextInstallmentNumber: plan.nextInstallmentNumber,\n          createdAt: plan.createdAt.toISOString(),\n          activatedAt: plan.activatedAt?.toISOString(),\n          completedAt: plan.completedAt?.toISOString(),\n          suspendedAt: plan.suspendedAt?.toISOString(),\n          cancelledAt: plan.cancelledAt?.toISOString(),\n        },\n        payment: payment ? {\n          id: payment.id,\n          installmentNumber: payment.installmentNumber,\n          amount: payment.amount,\n          expectedAmount: payment.expectedAmount,\n          txHash: payment.txHash,\n          status: payment.status,\n          dueDate: payment.dueDate.toISOString(),\n          createdAt: payment.createdAt.toISOString(),\n          confirmedAt: payment.confirmedAt?.toISOString(),\n        } : undefined,\n        payLink: {\n          id: payLink.id,\n          targetUrl: payLink.targetUrl,\n          price: payLink.price,\n          recipientAddress: payLink.recipientAddress,\n          installment: payLink.installment ? {\n            totalInstallments: payLink.installment.totalInstallments,\n            intervalDays: payLink.installment.intervalDays,\n            downPaymentPercent: payLink.installment.downPaymentPercent,\n          } : undefined,\n        },\n      },\n    };\n\n    return this.send(payload);\n  }\n\n  /**\n   * Queue event for async delivery\n   */\n  queueEvent(payload: WebhookPayload): void {\n    this.queue.push({ payload, attempt: 0 });\n    this.processQueue();\n  }\n\n  /**\n   * Send webhook with retries\n   */\n  async send(payload: WebhookPayload): Promise<WebhookResult> {\n    const startTime = Date.now();\n    let lastError: string | undefined;\n    let lastStatusCode: number | undefined;\n\n    for (let attempt = 1; attempt <= this.config.retries; attempt++) {\n      try {\n        const result = await this.deliver(payload);\n        \n        if (result.success) {\n          return {\n            success: true,\n            statusCode: result.statusCode,\n            attempts: attempt,\n            duration: Date.now() - startTime,\n          };\n        }\n\n        lastStatusCode = result.statusCode;\n        lastError = result.error;\n\n        // Don't retry on 4xx errors (client errors)\n        if (result.statusCode && result.statusCode >= 400 && result.statusCode < 500) {\n          break;\n        }\n\n        // Wait before retry (exponential backoff)\n        if (attempt < this.config.retries) {\n          await this.delay(Math.pow(2, attempt) * 1000);\n        }\n      } catch (error) {\n        lastError = (error as Error).message;\n        \n        if (attempt < this.config.retries) {\n          await this.delay(Math.pow(2, attempt) * 1000);\n        }\n      }\n    }\n\n    return {\n      success: false,\n      statusCode: lastStatusCode,\n      error: lastError,\n      attempts: this.config.retries,\n      duration: Date.now() - startTime,\n    };\n  }\n\n  /**\n   * Deliver webhook\n   */\n  private async deliver(\n    payload: WebhookPayload\n  ): Promise<{ success: boolean; statusCode?: number; error?: string }> {\n    const controller = new AbortController();\n    const timeout = setTimeout(() => controller.abort(), this.config.timeout);\n\n    try {\n      const body = JSON.stringify(payload);\n      const headers: Record<string, string> = {\n        'Content-Type': 'application/json',\n        'User-Agent': 'Paylink-Webhook/1.1.0',\n        'X-Paylink-Event': payload.event,\n        'X-Paylink-Event-Id': payload.eventId,\n        'X-Paylink-Timestamp': payload.timestamp,\n        ...this.config.headers,\n      };\n\n      // Add HMAC signature if secret is configured\n      if (this.config.secret) {\n        headers['X-Paylink-Signature'] = this.sign(body);\n      }\n\n      const response = await fetch(this.config.url, {\n        method: 'POST',\n        headers,\n        body,\n        signal: controller.signal,\n      });\n\n      if (response.ok) {\n        return { success: true, statusCode: response.status };\n      }\n\n      return {\n        success: false,\n        statusCode: response.status,\n        error: `HTTP ${response.status}: ${response.statusText}`,\n      };\n    } catch (error) {\n      if ((error as Error).name === 'AbortError') {\n        return { success: false, error: 'Request timeout' };\n      }\n      return { success: false, error: (error as Error).message };\n    } finally {\n      clearTimeout(timeout);\n    }\n  }\n\n  /**\n   * Sign payload with HMAC-SHA256\n   */\n  private sign(body: string): string {\n    if (!this.config.secret) return '';\n    return createHmac('sha256', this.config.secret).update(body).digest('hex');\n  }\n\n  /**\n   * Generate unique event ID\n   */\n  private generateEventId(): string {\n    const timestamp = Date.now().toString(36);\n    const random = Math.random().toString(36).substring(2, 10);\n    return `evt_${timestamp}_${random}`;\n  }\n\n  /**\n   * Process queued events\n   */\n  private async processQueue(): Promise<void> {\n    if (this.processing) return;\n    this.processing = true;\n\n    while (this.queue.length > 0) {\n      const item = this.queue.shift();\n      if (!item) continue;\n\n      const result = await this.send(item.payload);\n      \n      if (!result.success) {\n        console.error(\n          `Webhook delivery failed for ${item.payload.event}:`,\n          result.error\n        );\n      }\n    }\n\n    this.processing = false;\n  }\n\n  /**\n   * Delay helper\n   */\n  private delay(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n}\n\n/**\n * Verify webhook signature\n * Use this in your webhook handler to verify authenticity\n */\nexport function verifyWebhookSignature(\n  body: string,\n  signature: string,\n  secret: string\n): boolean {\n  const expected = createHmac('sha256', secret).update(body).digest('hex');\n  \n  // Constant-time comparison to prevent timing attacks\n  if (signature.length !== expected.length) return false;\n  \n  let result = 0;\n  for (let i = 0; i < signature.length; i++) {\n    result |= signature.charCodeAt(i) ^ expected.charCodeAt(i);\n  }\n  \n  return result === 0;\n}\n\n/**\n * Create a webhook manager\n */\nexport function createWebhookManager(config: WebhookConfig): WebhookManager {\n  return new WebhookManager(config);\n}\n","/**\n * QR Code Generator\n * Generates QR codes for payment links with wallet deep links\n */\n\n// QR Code matrix generation using Reed-Solomon error correction\n// This is a pure TypeScript implementation without external dependencies\n\nconst EC_LEVEL = 1; // M = ~15% error correction\nconst MODE_BYTE = 4; // Byte mode indicator\n\n/**\n * QR Code options\n */\nexport interface QRCodeOptions {\n  /** Size in pixels (default: 256) */\n  size?: number;\n  /** Margin in modules (default: 4) */\n  margin?: number;\n  /** Dark color (default: #000000) */\n  darkColor?: string;\n  /** Light color (default: #ffffff) */\n  lightColor?: string;\n  /** Output format */\n  format?: 'svg' | 'png-base64';\n}\n\n/**\n * Payment QR data\n */\nexport interface PaymentQRData {\n  /** Chain ID */\n  chainId: number;\n  /** Recipient address */\n  recipient: string;\n  /** Amount to pay */\n  amount: string;\n  /** Token symbol */\n  tokenSymbol: string;\n  /** Payment link ID */\n  payLinkId: string;\n  /** Callback URL for confirmation */\n  confirmUrl: string;\n}\n\n/**\n * Generate a payment URI for wallets\n */\nexport function generatePaymentURI(data: PaymentQRData): string {\n  const { chainId, recipient, amount, tokenSymbol } = data;\n\n  // Solana (chainId 101 = mainnet, 102 = devnet, 103 = testnet)\n  if (chainId >= 101 && chainId <= 103) {\n    // Solana Pay URI format\n    // solana:<recipient>?amount=<amount>&label=<label>&message=<message>\n    const params = new URLSearchParams({\n      amount: amount,\n      label: 'Paylink Payment',\n      message: `Payment for ${data.payLinkId}`,\n    });\n    return `solana:${recipient}?${params.toString()}`;\n  }\n\n  // EVM chains - use EIP-681 format\n  // ethereum:<address>@<chainId>/transfer?value=<value>\n  const weiAmount = parseFloat(amount) * 1e18;\n  \n  // Determine scheme based on chain\n  let scheme = 'ethereum';\n  if (chainId === 137 || chainId === 80001) {\n    scheme = 'polygon';\n  } else if (chainId === 56 || chainId === 97) {\n    scheme = 'bnb';\n  } else if (chainId === 42161 || chainId === 421613) {\n    scheme = 'arbitrum';\n  }\n\n  return `${scheme}:${recipient}@${chainId}?value=${weiAmount.toFixed(0)}`;\n}\n\n/**\n * Generate QR code as SVG\n */\nexport function generateQRCodeSVG(data: string, options: QRCodeOptions = {}): string {\n  const {\n    size = 256,\n    margin = 4,\n    darkColor = '#000000',\n    lightColor = '#ffffff',\n  } = options;\n\n  const matrix = generateQRMatrix(data);\n  const moduleCount = matrix.length;\n  const moduleSize = size / (moduleCount + margin * 2);\n\n  let svg = `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 ${size} ${size}\" width=\"${size}\" height=\"${size}\">`;\n  svg += `<rect width=\"${size}\" height=\"${size}\" fill=\"${lightColor}\"/>`;\n\n  for (let row = 0; row < moduleCount; row++) {\n    for (let col = 0; col < moduleCount; col++) {\n      if (matrix[row][col]) {\n        const x = (col + margin) * moduleSize;\n        const y = (row + margin) * moduleSize;\n        svg += `<rect x=\"${x}\" y=\"${y}\" width=\"${moduleSize}\" height=\"${moduleSize}\" fill=\"${darkColor}\"/>`;\n      }\n    }\n  }\n\n  svg += '</svg>';\n  return svg;\n}\n\n/**\n * Generate QR code as data URL (base64 PNG simulation via SVG)\n */\nexport function generateQRCodeDataURL(data: string, options: QRCodeOptions = {}): string {\n  const svg = generateQRCodeSVG(data, options);\n  const base64 = Buffer.from(svg).toString('base64');\n  return `data:image/svg+xml;base64,${base64}`;\n}\n\n/**\n * Generate complete payment QR code\n */\nexport function generatePaymentQR(\n  data: PaymentQRData,\n  options: QRCodeOptions = {}\n): { uri: string; svg: string; dataUrl: string } {\n  const uri = generatePaymentURI(data);\n  const svg = generateQRCodeSVG(uri, options);\n  const dataUrl = generateQRCodeDataURL(uri, options);\n\n  return { uri, svg, dataUrl };\n}\n\n// ============================================\n// QR Matrix Generation (Simplified Version 2)\n// ============================================\n\nfunction generateQRMatrix(data: string): boolean[][] {\n  const bytes = Buffer.from(data, 'utf8');\n  const version = getMinVersion(bytes.length);\n  const size = version * 4 + 17;\n\n  // Initialize matrix\n  const matrix: boolean[][] = Array(size)\n    .fill(null)\n    .map(() => Array(size).fill(false));\n\n  const reserved: boolean[][] = Array(size)\n    .fill(null)\n    .map(() => Array(size).fill(false));\n\n  // Add finder patterns\n  addFinderPattern(matrix, reserved, 0, 0);\n  addFinderPattern(matrix, reserved, size - 7, 0);\n  addFinderPattern(matrix, reserved, 0, size - 7);\n\n  // Add timing patterns\n  addTimingPatterns(matrix, reserved, size);\n\n  // Add alignment patterns (for version 2+)\n  if (version >= 2) {\n    addAlignmentPatterns(matrix, reserved, version, size);\n  }\n\n  // Reserve format info areas\n  reserveFormatAreas(reserved, size);\n\n  // Encode data\n  const encoded = encodeData(bytes, version);\n\n  // Place data in matrix\n  placeData(matrix, reserved, encoded, size);\n\n  // Apply mask (using mask 0 for simplicity)\n  applyMask(matrix, reserved, size, 0);\n\n  // Add format info\n  addFormatInfo(matrix, size, 0);\n\n  return matrix;\n}\n\nfunction getMinVersion(dataLength: number): number {\n  // Simplified version selection for byte mode with M error correction\n  const capacities = [0, 14, 26, 42, 62, 84, 106, 122, 152, 180, 213];\n  for (let v = 1; v <= 10; v++) {\n    if (dataLength <= capacities[v]) return v;\n  }\n  return 10; // Max version we support\n}\n\nfunction addFinderPattern(\n  matrix: boolean[][],\n  reserved: boolean[][],\n  row: number,\n  col: number\n): void {\n  for (let r = -1; r <= 7; r++) {\n    for (let c = -1; c <= 7; c++) {\n      const rr = row + r;\n      const cc = col + c;\n      if (rr < 0 || cc < 0 || rr >= matrix.length || cc >= matrix.length) continue;\n\n      reserved[rr][cc] = true;\n\n      if (r === -1 || r === 7 || c === -1 || c === 7) {\n        matrix[rr][cc] = false;\n      } else if (r === 0 || r === 6 || c === 0 || c === 6) {\n        matrix[rr][cc] = true;\n      } else if (r >= 2 && r <= 4 && c >= 2 && c <= 4) {\n        matrix[rr][cc] = true;\n      } else {\n        matrix[rr][cc] = false;\n      }\n    }\n  }\n}\n\nfunction addTimingPatterns(matrix: boolean[][], reserved: boolean[][], size: number): void {\n  for (let i = 8; i < size - 8; i++) {\n    const bit = i % 2 === 0;\n    matrix[6][i] = bit;\n    matrix[i][6] = bit;\n    reserved[6][i] = true;\n    reserved[i][6] = true;\n  }\n}\n\nfunction addAlignmentPatterns(\n  matrix: boolean[][],\n  reserved: boolean[][],\n  version: number,\n  size: number\n): void {\n  const positions = getAlignmentPositions(version);\n\n  for (const row of positions) {\n    for (const col of positions) {\n      // Skip if overlapping with finder patterns\n      if (\n        (row < 9 && col < 9) ||\n        (row < 9 && col > size - 10) ||\n        (row > size - 10 && col < 9)\n      ) {\n        continue;\n      }\n\n      for (let r = -2; r <= 2; r++) {\n        for (let c = -2; c <= 2; c++) {\n          const rr = row + r;\n          const cc = col + c;\n          reserved[rr][cc] = true;\n\n          if (r === -2 || r === 2 || c === -2 || c === 2) {\n            matrix[rr][cc] = true;\n          } else if (r === 0 && c === 0) {\n            matrix[rr][cc] = true;\n          } else {\n            matrix[rr][cc] = false;\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction getAlignmentPositions(version: number): number[] {\n  if (version === 1) return [];\n  const positions = [6];\n  const step = Math.floor((version * 4 + 10) / (Math.floor(version / 7) + 1));\n  let pos = version * 4 + 10;\n  while (pos > 6 + step) {\n    positions.unshift(pos);\n    pos -= step;\n  }\n  positions.unshift(6);\n  return [...new Set(positions)].sort((a, b) => a - b);\n}\n\nfunction reserveFormatAreas(reserved: boolean[][], size: number): void {\n  // Around top-left finder\n  for (let i = 0; i < 9; i++) {\n    reserved[8][i] = true;\n    reserved[i][8] = true;\n  }\n  // Around top-right finder\n  for (let i = 0; i < 8; i++) {\n    reserved[8][size - 1 - i] = true;\n  }\n  // Around bottom-left finder\n  for (let i = 0; i < 8; i++) {\n    reserved[size - 1 - i][8] = true;\n  }\n  // Dark module\n  reserved[size - 8][8] = true;\n}\n\nfunction encodeData(data: Buffer, version: number): boolean[] {\n  const bits: boolean[] = [];\n\n  // Mode indicator (byte mode = 0100)\n  pushBits(bits, MODE_BYTE, 4);\n\n  // Character count (8 bits for version 1-9, 16 for 10+)\n  const countBits = version < 10 ? 8 : 16;\n  pushBits(bits, data.length, countBits);\n\n  // Data\n  for (const byte of data) {\n    pushBits(bits, byte, 8);\n  }\n\n  // Terminator\n  const capacity = getDataCapacity(version);\n  const remaining = capacity - bits.length;\n  if (remaining > 0) {\n    pushBits(bits, 0, Math.min(4, remaining));\n  }\n\n  // Pad to byte boundary\n  while (bits.length % 8 !== 0) {\n    bits.push(false);\n  }\n\n  // Pad codewords\n  const padBytes = [0xec, 0x11];\n  let padIndex = 0;\n  while (bits.length < capacity) {\n    pushBits(bits, padBytes[padIndex % 2], 8);\n    padIndex++;\n  }\n\n  // Add error correction\n  return addErrorCorrection(bits, version);\n}\n\nfunction getDataCapacity(version: number): number {\n  // Data capacity in bits for M error correction level\n  const capacities = [0, 128, 224, 352, 512, 688, 864, 992, 1232, 1456, 1728];\n  return capacities[version] || 1728;\n}\n\nfunction pushBits(arr: boolean[], value: number, count: number): void {\n  for (let i = count - 1; i >= 0; i--) {\n    arr.push(((value >> i) & 1) === 1);\n  }\n}\n\nfunction addErrorCorrection(data: boolean[], version: number): boolean[] {\n  // Simplified: For versions 1-10 with M level, add basic EC\n  // In production, use proper Reed-Solomon encoding\n\n  const dataBytes: number[] = [];\n  for (let i = 0; i < data.length; i += 8) {\n    let byte = 0;\n    for (let j = 0; j < 8 && i + j < data.length; j++) {\n      if (data[i + j]) byte |= 1 << (7 - j);\n    }\n    dataBytes.push(byte);\n  }\n\n  // Generate EC codewords (simplified polynomial division)\n  const ecCount = getECCount(version);\n  const ecBytes = generateECBytes(dataBytes, ecCount);\n\n  // Combine data and EC\n  const result: boolean[] = [...data];\n  for (const byte of ecBytes) {\n    pushBits(result, byte, 8);\n  }\n\n  return result;\n}\n\nfunction getECCount(version: number): number {\n  // EC codewords for M level\n  const counts = [0, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26];\n  return counts[version] || 26;\n}\n\nfunction generateECBytes(data: number[], ecCount: number): number[] {\n  // Simplified Reed-Solomon using GF(256)\n  const gfExp = new Uint8Array(512);\n  const gfLog = new Uint8Array(256);\n\n  // Generate GF tables\n  let x = 1;\n  for (let i = 0; i < 255; i++) {\n    gfExp[i] = x;\n    gfLog[x] = i;\n    x <<= 1;\n    if (x & 0x100) x ^= 0x11d;\n  }\n  for (let i = 255; i < 512; i++) {\n    gfExp[i] = gfExp[i - 255];\n  }\n\n  // Generate generator polynomial\n  const gen: number[] = [1];\n  for (let i = 0; i < ecCount; i++) {\n    const newGen: number[] = new Array(gen.length + 1).fill(0);\n    for (let j = 0; j < gen.length; j++) {\n      newGen[j] ^= gen[j];\n      newGen[j + 1] ^= gfExp[(gfLog[gen[j]] + i) % 255];\n    }\n    gen.length = 0;\n    gen.push(...newGen);\n  }\n\n  // Perform polynomial division\n  const msg = [...data, ...new Array(ecCount).fill(0)];\n  for (let i = 0; i < data.length; i++) {\n    const coef = msg[i];\n    if (coef !== 0) {\n      for (let j = 1; j < gen.length; j++) {\n        if (gen[j] !== 0) {\n          msg[i + j] ^= gfExp[(gfLog[gen[j]] + gfLog[coef]) % 255];\n        }\n      }\n    }\n  }\n\n  return msg.slice(data.length);\n}\n\nfunction placeData(\n  matrix: boolean[][],\n  reserved: boolean[][],\n  data: boolean[],\n  size: number\n): void {\n  let dataIndex = 0;\n  let upward = true;\n\n  for (let col = size - 1; col > 0; col -= 2) {\n    if (col === 6) col = 5; // Skip timing pattern column\n\n    for (let i = 0; i < size; i++) {\n      const row = upward ? size - 1 - i : i;\n\n      for (const c of [col, col - 1]) {\n        if (!reserved[row][c] && dataIndex < data.length) {\n          matrix[row][c] = data[dataIndex++];\n        }\n      }\n    }\n\n    upward = !upward;\n  }\n}\n\nfunction applyMask(\n  matrix: boolean[][],\n  reserved: boolean[][],\n  size: number,\n  mask: number\n): void {\n  for (let row = 0; row < size; row++) {\n    for (let col = 0; col < size; col++) {\n      if (!reserved[row][col] && shouldMask(row, col, mask)) {\n        matrix[row][col] = !matrix[row][col];\n      }\n    }\n  }\n}\n\nfunction shouldMask(row: number, col: number, mask: number): boolean {\n  switch (mask) {\n    case 0:\n      return (row + col) % 2 === 0;\n    case 1:\n      return row % 2 === 0;\n    case 2:\n      return col % 3 === 0;\n    case 3:\n      return (row + col) % 3 === 0;\n    case 4:\n      return (Math.floor(row / 2) + Math.floor(col / 3)) % 2 === 0;\n    case 5:\n      return ((row * col) % 2) + ((row * col) % 3) === 0;\n    case 6:\n      return (((row * col) % 2) + ((row * col) % 3)) % 2 === 0;\n    case 7:\n      return (((row + col) % 2) + ((row * col) % 3)) % 2 === 0;\n    default:\n      return false;\n  }\n}\n\nfunction addFormatInfo(matrix: boolean[][], size: number, mask: number): void {\n  // Format info for EC level M (01) and mask\n  const formatBits = getFormatBits(EC_LEVEL, mask);\n\n  // Place format info\n  for (let i = 0; i < 15; i++) {\n    const bit = formatBits[i];\n\n    // Around top-left\n    if (i < 6) {\n      matrix[i][8] = bit;\n    } else if (i < 8) {\n      matrix[i + 1][8] = bit;\n    } else {\n      matrix[8][14 - i] = bit;\n    }\n\n    // Around top-right and bottom-left\n    if (i < 8) {\n      matrix[8][size - 1 - i] = bit;\n    } else {\n      matrix[size - 15 + i][8] = bit;\n    }\n  }\n\n  // Dark module\n  matrix[size - 8][8] = true;\n}\n\nfunction getFormatBits(ecLevel: number, mask: number): boolean[] {\n  // Pre-computed format strings for M level (01) and masks 0-7\n  const formats: { [key: string]: string } = {\n    '1-0': '101010000010010',\n    '1-1': '101000100100101',\n    '1-2': '101111001111100',\n    '1-3': '101101101001011',\n    '1-4': '100010111111001',\n    '1-5': '100000011001110',\n    '1-6': '100111110010111',\n    '1-7': '100101010100000',\n  };\n\n  const key = `${ecLevel}-${mask}`;\n  const format = formats[key] || formats['1-0'];\n\n  return format.split('').map(c => c === '1');\n}\n","import type {\n  Subscription,\n  SubscriptionConfig,\n  SubscriptionInterval,\n  SubscriptionStatus,\n  PayLink,\n  Payment,\n  Storage,\n  CreateSubscriptionInput,\n} from './types.js';\nimport { generateId, generateUUID } from './utils.js';\n\n/**\n * Calculate next billing date based on interval\n */\nexport function calculateNextBillingDate(\n  fromDate: Date,\n  interval: SubscriptionInterval,\n  intervalCount: number = 1\n): Date {\n  const date = new Date(fromDate);\n\n  switch (interval) {\n    case 'daily':\n      date.setDate(date.getDate() + intervalCount);\n      break;\n    case 'weekly':\n      date.setDate(date.getDate() + (7 * intervalCount));\n      break;\n    case 'monthly':\n      date.setMonth(date.getMonth() + intervalCount);\n      break;\n    case 'yearly':\n      date.setFullYear(date.getFullYear() + intervalCount);\n      break;\n  }\n\n  return date;\n}\n\n/**\n * Check if subscription is within grace period\n */\nexport function isWithinGracePeriod(\n  nextPaymentDue: Date,\n  gracePeriodHours: number = 24\n): boolean {\n  const now = new Date();\n  const graceEnd = new Date(nextPaymentDue);\n  graceEnd.setHours(graceEnd.getHours() + gracePeriodHours);\n  return now <= graceEnd;\n}\n\n/**\n * Check if subscription payment is due\n */\nexport function isPaymentDue(subscription: Subscription): boolean {\n  const now = new Date();\n  return now >= subscription.nextPaymentDue;\n}\n\n/**\n * Check if subscription is in trial period\n */\nexport function isInTrialPeriod(subscription: Subscription): boolean {\n  if (!subscription.trialEndsAt) return false;\n  return new Date() < subscription.trialEndsAt;\n}\n\n/**\n * Get interval display name\n */\nexport function getIntervalDisplayName(\n  interval: SubscriptionInterval,\n  count: number = 1\n): string {\n  const labels: Record<SubscriptionInterval, [string, string]> = {\n    daily: ['day', 'days'],\n    weekly: ['week', 'weeks'],\n    monthly: ['month', 'months'],\n    yearly: ['year', 'years'],\n  };\n\n  const [singular, plural] = labels[interval];\n  if (count === 1) return singular;\n  return `${count} ${plural}`;\n}\n\n/**\n * Subscription Manager\n * Handles subscription lifecycle and billing\n */\nexport class SubscriptionManager {\n  private storage: Storage;\n  private checkInterval: NodeJS.Timeout | null = null;\n\n  constructor(storage: Storage) {\n    this.storage = storage;\n  }\n\n  /**\n   * Create a new subscription\n   */\n  async createSubscription(\n    payLink: PayLink,\n    input: CreateSubscriptionInput\n  ): Promise<Subscription> {\n    if (!payLink.subscription) {\n      throw new Error('PayLink is not configured for subscriptions');\n    }\n\n    const config = payLink.subscription;\n    const now = new Date();\n\n    // Check for existing subscription\n    const existing = await this.storage.getSubscriptionByAddress(\n      payLink.id,\n      input.subscriberAddress\n    );\n\n    if (existing && existing.status === 'active') {\n      throw new Error('Active subscription already exists for this address');\n    }\n\n    // Calculate dates\n    const trialEndsAt = config.trialDays\n      ? new Date(now.getTime() + config.trialDays * 24 * 60 * 60 * 1000)\n      : undefined;\n\n    const periodStart = trialEndsAt ?? now;\n    const periodEnd = calculateNextBillingDate(\n      periodStart,\n      config.interval,\n      config.intervalCount\n    );\n\n    const subscription: Subscription = {\n      id: generateId(12),\n      payLinkId: payLink.id,\n      subscriberAddress: input.subscriberAddress,\n      status: 'active',\n      currentPeriodStart: periodStart,\n      currentPeriodEnd: periodEnd,\n      nextPaymentDue: trialEndsAt ?? now,\n      cycleCount: 0,\n      createdAt: now,\n      updatedAt: now,\n      trialEndsAt,\n      metadata: input.metadata,\n    };\n\n    await this.storage.saveSubscription(subscription);\n    return subscription;\n  }\n\n  /**\n   * Process payment for subscription\n   */\n  async processPayment(\n    subscription: Subscription,\n    payment: Payment,\n    payLink: PayLink\n  ): Promise<Subscription> {\n    if (!payLink.subscription) {\n      throw new Error('PayLink is not configured for subscriptions');\n    }\n\n    const config = payLink.subscription;\n    const now = new Date();\n\n    // Calculate new period\n    const newPeriodStart = subscription.currentPeriodEnd;\n    const newPeriodEnd = calculateNextBillingDate(\n      newPeriodStart,\n      config.interval,\n      config.intervalCount\n    );\n\n    // Update subscription\n    subscription.currentPeriodStart = newPeriodStart;\n    subscription.currentPeriodEnd = newPeriodEnd;\n    subscription.nextPaymentDue = newPeriodEnd;\n    subscription.cycleCount += 1;\n    subscription.lastPaymentId = payment.id;\n    subscription.status = 'active';\n    subscription.updatedAt = now;\n\n    // Check max cycles\n    if (config.maxCycles && subscription.cycleCount >= config.maxCycles) {\n      subscription.status = 'expired';\n    }\n\n    await this.storage.updateSubscription(subscription);\n    return subscription;\n  }\n\n  /**\n   * Cancel subscription\n   */\n  async cancelSubscription(\n    subscriptionId: string,\n    immediate: boolean = false\n  ): Promise<Subscription> {\n    const subscription = await this.storage.getSubscription(subscriptionId);\n    if (!subscription) {\n      throw new Error('Subscription not found');\n    }\n\n    subscription.status = 'cancelled';\n    subscription.cancelledAt = new Date();\n    subscription.updatedAt = new Date();\n\n    await this.storage.updateSubscription(subscription);\n    return subscription;\n  }\n\n  /**\n   * Pause subscription\n   */\n  async pauseSubscription(subscriptionId: string): Promise<Subscription> {\n    const subscription = await this.storage.getSubscription(subscriptionId);\n    if (!subscription) {\n      throw new Error('Subscription not found');\n    }\n\n    if (subscription.status !== 'active') {\n      throw new Error('Only active subscriptions can be paused');\n    }\n\n    subscription.status = 'paused';\n    subscription.pausedAt = new Date();\n    subscription.updatedAt = new Date();\n\n    await this.storage.updateSubscription(subscription);\n    return subscription;\n  }\n\n  /**\n   * Resume subscription\n   */\n  async resumeSubscription(subscriptionId: string): Promise<Subscription> {\n    const subscription = await this.storage.getSubscription(subscriptionId);\n    if (!subscription) {\n      throw new Error('Subscription not found');\n    }\n\n    if (subscription.status !== 'paused') {\n      throw new Error('Only paused subscriptions can be resumed');\n    }\n\n    subscription.status = 'active';\n    subscription.pausedAt = undefined;\n    subscription.updatedAt = new Date();\n\n    await this.storage.updateSubscription(subscription);\n    return subscription;\n  }\n\n  /**\n   * Check subscription access\n   * Returns true if subscription grants access to the resource\n   */\n  async checkAccess(subscription: Subscription, payLink: PayLink): Promise<{\n    hasAccess: boolean;\n    reason?: string;\n    requiresPayment?: boolean;\n  }> {\n    // Check if cancelled\n    if (subscription.status === 'cancelled') {\n      return {\n        hasAccess: false,\n        reason: 'Subscription has been cancelled',\n      };\n    }\n\n    // Check if expired\n    if (subscription.status === 'expired') {\n      return {\n        hasAccess: false,\n        reason: 'Subscription has expired',\n      };\n    }\n\n    // Check if paused\n    if (subscription.status === 'paused') {\n      return {\n        hasAccess: false,\n        reason: 'Subscription is paused',\n      };\n    }\n\n    // Check trial period\n    if (isInTrialPeriod(subscription)) {\n      return { hasAccess: true };\n    }\n\n    // Check if payment is due\n    if (isPaymentDue(subscription)) {\n      const gracePeriodHours = payLink.subscription?.gracePeriodHours ?? 24;\n\n      if (isWithinGracePeriod(subscription.nextPaymentDue, gracePeriodHours)) {\n        // Still in grace period\n        return {\n          hasAccess: true,\n          requiresPayment: true,\n        };\n      }\n\n      // Past grace period\n      return {\n        hasAccess: false,\n        reason: 'Payment is past due',\n        requiresPayment: true,\n      };\n    }\n\n    return { hasAccess: true };\n  }\n\n  /**\n   * Mark subscription as past due\n   */\n  async markPastDue(subscriptionId: string): Promise<Subscription> {\n    const subscription = await this.storage.getSubscription(subscriptionId);\n    if (!subscription) {\n      throw new Error('Subscription not found');\n    }\n\n    subscription.status = 'past_due';\n    subscription.updatedAt = new Date();\n\n    await this.storage.updateSubscription(subscription);\n    return subscription;\n  }\n\n  /**\n   * Get subscription by ID\n   */\n  async getSubscription(id: string): Promise<Subscription | null> {\n    return this.storage.getSubscription(id);\n  }\n\n  /**\n   * Get subscription by subscriber address\n   */\n  async getSubscriptionByAddress(\n    payLinkId: string,\n    subscriberAddress: string\n  ): Promise<Subscription | null> {\n    return this.storage.getSubscriptionByAddress(payLinkId, subscriberAddress);\n  }\n\n  /**\n   * Get all subscriptions due for payment\n   */\n  async getDueSubscriptions(): Promise<Subscription[]> {\n    return this.storage.getSubscriptionsDue(new Date());\n  }\n\n  /**\n   * Start periodic check for due subscriptions\n   */\n  startPeriodicCheck(\n    intervalMs: number = 60000,\n    onDue?: (subscription: Subscription) => void\n  ): void {\n    if (this.checkInterval) {\n      clearInterval(this.checkInterval);\n    }\n\n    this.checkInterval = setInterval(async () => {\n      try {\n        const dueSubscriptions = await this.getDueSubscriptions();\n        for (const sub of dueSubscriptions) {\n          if (onDue) {\n            onDue(sub);\n          }\n        }\n      } catch (error) {\n        console.error('Subscription check error:', error);\n      }\n    }, intervalMs);\n  }\n\n  /**\n   * Stop periodic check\n   */\n  stopPeriodicCheck(): void {\n    if (this.checkInterval) {\n      clearInterval(this.checkInterval);\n      this.checkInterval = null;\n    }\n  }\n}\n\n/**\n * Create subscription manager\n */\nexport function createSubscriptionManager(storage: Storage): SubscriptionManager {\n  return new SubscriptionManager(storage);\n}\n","/**\n * Referral System\n * Viral growth through referral rewards\n * \n * Features:\n * - Generate unique referral codes\n * - Track referrals per link\n * - Calculate and track commissions\n * - Support for commission payouts\n */\n\nimport type {\n  Referral,\n  ReferralCommission,\n  ReferralConfig,\n  ReferralStats,\n  ReferralStatus,\n  CreateReferralInput,\n  PayLink,\n  Payment,\n  Storage,\n} from './types.js';\nimport { generateId } from './utils.js';\n\n/**\n * Default referral configuration\n */\nexport const DEFAULT_REFERRAL_CONFIG: ReferralConfig = {\n  enabled: true,\n  commissionPercent: 10,\n  minPayoutThreshold: undefined,\n  expirationDays: undefined,\n};\n\n/**\n * Generate a unique referral code\n * Format: 6-8 alphanumeric characters, URL-safe\n */\nexport function generateReferralCode(length: number = 8): string {\n  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // Removed ambiguous chars (0, O, 1, I)\n  let code = '';\n  for (let i = 0; i < length; i++) {\n    code += chars.charAt(Math.floor(Math.random() * chars.length));\n  }\n  return code;\n}\n\n/**\n * Validate referral code format\n */\nexport function isValidReferralCode(code: string): boolean {\n  return /^[A-Z0-9]{4,16}$/i.test(code);\n}\n\n/**\n * Calculate commission amount\n */\nexport function calculateCommission(\n  paymentAmount: string,\n  commissionPercent: number\n): string {\n  const amount = parseFloat(paymentAmount);\n  const commission = (amount * commissionPercent) / 100;\n  // Round to 8 decimal places for crypto precision\n  return commission.toFixed(8).replace(/\\.?0+$/, '');\n}\n\n/**\n * Check if commission has expired\n */\nexport function isCommissionExpired(\n  createdAt: Date,\n  expirationDays?: number\n): boolean {\n  if (!expirationDays) return false;\n  \n  const expiresAt = new Date(createdAt);\n  expiresAt.setDate(expiresAt.getDate() + expirationDays);\n  \n  return new Date() > expiresAt;\n}\n\n/**\n * Referral Manager\n * Handles referral creation, tracking, and commission calculations\n */\nexport class ReferralManager {\n  private storage: Storage;\n\n  constructor(storage: Storage) {\n    this.storage = storage;\n  }\n\n  /**\n   * Create a new referral\n   */\n  async createReferral(input: CreateReferralInput): Promise<Referral> {\n    const payLink = await this.storage.getPayLink(input.payLinkId);\n    \n    if (!payLink) {\n      throw new Error('PayLink not found');\n    }\n\n    if (!payLink.referral?.enabled) {\n      throw new Error('Referral program is not enabled for this link');\n    }\n\n    // Check if referrer already has a referral for this link\n    const existingReferrals = await this.storage.getReferralsByPayLink(input.payLinkId);\n    const existing = existingReferrals.find(\n      r => r.referrerAddress.toLowerCase() === input.referrerAddress.toLowerCase()\n    );\n\n    if (existing) {\n      throw new Error('Referral already exists for this address');\n    }\n\n    // Generate or validate code\n    let code = input.code;\n    if (code) {\n      if (!isValidReferralCode(code)) {\n        throw new Error('Invalid referral code format');\n      }\n      // Check if code already exists\n      const existingCode = await this.storage.getReferralByCode(code);\n      if (existingCode) {\n        throw new Error('Referral code already in use');\n      }\n    } else {\n      // Generate unique code\n      let attempts = 0;\n      do {\n        code = generateReferralCode();\n        const existingCode = await this.storage.getReferralByCode(code);\n        if (!existingCode) break;\n        attempts++;\n      } while (attempts < 10);\n\n      if (attempts >= 10) {\n        throw new Error('Failed to generate unique referral code');\n      }\n    }\n\n    const now = new Date();\n    const referral: Referral = {\n      id: generateId(12),\n      code: code!,\n      referrerAddress: input.referrerAddress,\n      payLinkId: input.payLinkId,\n      totalReferrals: 0,\n      confirmedReferrals: 0,\n      totalEarned: '0',\n      pendingAmount: '0',\n      paidAmount: '0',\n      status: 'active',\n      createdAt: now,\n      updatedAt: now,\n      metadata: input.metadata,\n    };\n\n    await this.storage.saveReferral(referral);\n    return referral;\n  }\n\n  /**\n   * Get referral by code\n   */\n  async getReferralByCode(code: string): Promise<Referral | null> {\n    return this.storage.getReferralByCode(code.toUpperCase());\n  }\n\n  /**\n   * Get referral by ID\n   */\n  async getReferral(id: string): Promise<Referral | null> {\n    return this.storage.getReferral(id);\n  }\n\n  /**\n   * Get all referrals for a PayLink\n   */\n  async getReferralsByPayLink(payLinkId: string): Promise<Referral[]> {\n    return this.storage.getReferralsByPayLink(payLinkId);\n  }\n\n  /**\n   * Get all referrals for a referrer\n   */\n  async getReferralsByReferrer(referrerAddress: string): Promise<Referral[]> {\n    return this.storage.getReferralsByReferrer(referrerAddress);\n  }\n\n  /**\n   * Process payment with referral\n   * Creates commission record and updates referral stats\n   */\n  async processReferralPayment(\n    payment: Payment,\n    payLink: PayLink,\n    referralCode: string\n  ): Promise<ReferralCommission | null> {\n    // Get referral by code\n    const referral = await this.storage.getReferralByCode(referralCode.toUpperCase());\n    \n    if (!referral) {\n      console.warn(`Referral code not found: ${referralCode}`);\n      return null;\n    }\n\n    // Verify referral is for this link\n    if (referral.payLinkId !== payLink.id) {\n      console.warn(`Referral code ${referralCode} is not valid for this link`);\n      return null;\n    }\n\n    // Check if referral is active\n    if (referral.status !== 'active') {\n      console.warn(`Referral ${referral.id} is not active`);\n      return null;\n    }\n\n    // Check if referral config exists\n    if (!payLink.referral?.enabled) {\n      console.warn(`Referral program is not enabled for link ${payLink.id}`);\n      return null;\n    }\n\n    // Prevent self-referral\n    if (referral.referrerAddress.toLowerCase() === payment.fromAddress.toLowerCase()) {\n      console.warn('Self-referral detected, skipping commission');\n      return null;\n    }\n\n    // Calculate commission\n    const commissionPercent = payLink.referral.commissionPercent;\n    const commissionAmount = calculateCommission(payment.amount, commissionPercent);\n\n    // Create commission record\n    const now = new Date();\n    const commission: ReferralCommission = {\n      id: generateId(12),\n      referralId: referral.id,\n      paymentId: payment.id,\n      payLinkId: payLink.id,\n      referrerAddress: referral.referrerAddress,\n      referredAddress: payment.fromAddress,\n      paymentAmount: payment.amount,\n      commissionAmount,\n      commissionPercent,\n      tokenSymbol: payment.tokenSymbol || payLink.price.tokenSymbol,\n      chainId: payment.chainId,\n      status: payment.confirmed ? 'confirmed' : 'pending',\n      createdAt: now,\n      confirmedAt: payment.confirmed ? now : undefined,\n    };\n\n    await this.storage.saveCommission(commission);\n\n    // Update referral stats\n    referral.totalReferrals += 1;\n    if (payment.confirmed) {\n      referral.confirmedReferrals += 1;\n      referral.pendingAmount = this.addAmounts(referral.pendingAmount, commissionAmount);\n      referral.totalEarned = this.addAmounts(referral.totalEarned, commissionAmount);\n    }\n    referral.updatedAt = now;\n\n    await this.storage.updateReferral(referral);\n\n    return commission;\n  }\n\n  /**\n   * Confirm pending commission (when payment is confirmed)\n   */\n  async confirmCommission(paymentId: string): Promise<ReferralCommission | null> {\n    const commissions = await this.storage.getAllCommissions();\n    const commission = commissions.find(c => c.paymentId === paymentId);\n\n    if (!commission) {\n      return null;\n    }\n\n    if (commission.status !== 'pending') {\n      return commission;\n    }\n\n    const now = new Date();\n    commission.status = 'confirmed';\n    commission.confirmedAt = now;\n\n    await this.storage.updateCommission(commission);\n\n    // Update referral stats\n    const referral = await this.storage.getReferral(commission.referralId);\n    if (referral) {\n      referral.confirmedReferrals += 1;\n      referral.pendingAmount = this.addAmounts(referral.pendingAmount, commission.commissionAmount);\n      referral.totalEarned = this.addAmounts(referral.totalEarned, commission.commissionAmount);\n      referral.updatedAt = now;\n      await this.storage.updateReferral(referral);\n    }\n\n    return commission;\n  }\n\n  /**\n   * Mark commission as paid\n   */\n  async markCommissionPaid(\n    commissionId: string,\n    payoutTxHash: string\n  ): Promise<ReferralCommission> {\n    const commission = await this.storage.getCommission(commissionId);\n\n    if (!commission) {\n      throw new Error('Commission not found');\n    }\n\n    if (commission.status !== 'confirmed') {\n      throw new Error('Commission is not in confirmed status');\n    }\n\n    const now = new Date();\n    commission.status = 'paid';\n    commission.paidAt = now;\n    commission.payoutTxHash = payoutTxHash;\n\n    await this.storage.updateCommission(commission);\n\n    // Update referral stats\n    const referral = await this.storage.getReferral(commission.referralId);\n    if (referral) {\n      referral.pendingAmount = this.subtractAmounts(referral.pendingAmount, commission.commissionAmount);\n      referral.paidAmount = this.addAmounts(referral.paidAmount, commission.commissionAmount);\n      referral.updatedAt = now;\n      await this.storage.updateReferral(referral);\n    }\n\n    return commission;\n  }\n\n  /**\n   * Get referral statistics for a referrer\n   */\n  async getStats(referrerAddress: string): Promise<ReferralStats> {\n    const commissions = await this.storage.getCommissionsByReferrer(referrerAddress);\n\n    let totalReferrals = 0;\n    let confirmedReferrals = 0;\n    let pendingReferrals = 0;\n    let totalEarned = 0;\n    let pendingPayout = 0;\n    let paidOut = 0;\n\n    for (const commission of commissions) {\n      totalReferrals++;\n      \n      if (commission.status === 'confirmed') {\n        confirmedReferrals++;\n        pendingPayout += parseFloat(commission.commissionAmount);\n        totalEarned += parseFloat(commission.commissionAmount);\n      } else if (commission.status === 'pending') {\n        pendingReferrals++;\n      } else if (commission.status === 'paid') {\n        confirmedReferrals++;\n        paidOut += parseFloat(commission.commissionAmount);\n        totalEarned += parseFloat(commission.commissionAmount);\n      }\n    }\n\n    const conversionRate = totalReferrals > 0 \n      ? (confirmedReferrals / totalReferrals) * 100 \n      : 0;\n\n    return {\n      totalReferrals,\n      confirmedReferrals,\n      pendingReferrals,\n      totalEarned: totalEarned.toString(),\n      pendingPayout: pendingPayout.toString(),\n      paidOut: paidOut.toString(),\n      conversionRate: Math.round(conversionRate * 100) / 100,\n    };\n  }\n\n  /**\n   * Disable a referral\n   */\n  async disableReferral(referralId: string): Promise<Referral> {\n    const referral = await this.storage.getReferral(referralId);\n\n    if (!referral) {\n      throw new Error('Referral not found');\n    }\n\n    referral.status = 'disabled';\n    referral.updatedAt = new Date();\n\n    await this.storage.updateReferral(referral);\n    return referral;\n  }\n\n  /**\n   * Get pending commissions for payout\n   */\n  async getPendingCommissions(referrerAddress: string): Promise<ReferralCommission[]> {\n    return this.storage.getPendingCommissions(referrerAddress);\n  }\n\n  /**\n   * Helper: Add string amounts\n   */\n  private addAmounts(a: string, b: string): string {\n    const result = parseFloat(a) + parseFloat(b);\n    return result.toFixed(8).replace(/\\.?0+$/, '');\n  }\n\n  /**\n   * Helper: Subtract string amounts\n   */\n  private subtractAmounts(a: string, b: string): string {\n    const result = parseFloat(a) - parseFloat(b);\n    return Math.max(0, result).toFixed(8).replace(/\\.?0+$/, '');\n  }\n}\n\n/**\n * Create a referral manager\n */\nexport function createReferralManager(storage: Storage): ReferralManager {\n  return new ReferralManager(storage);\n}\n\n/**\n * Build referral URL\n */\nexport function buildReferralUrl(baseUrl: string, linkId: string, referralCode: string): string {\n  return `${baseUrl}/pay/${linkId}?ref=${referralCode}`;\n}\n\n/**\n * Parse referral code from URL or query string\n */\nexport function parseReferralCode(input: string): string | null {\n  // Try URL\n  try {\n    const url = new URL(input);\n    const ref = url.searchParams.get('ref');\n    if (ref && isValidReferralCode(ref)) {\n      return ref.toUpperCase();\n    }\n  } catch {\n    // Not a URL, check if it's a direct code\n    if (isValidReferralCode(input)) {\n      return input.toUpperCase();\n    }\n  }\n  return null;\n}\n","/**\n * Installment (Payment Plan) Module\n * \n * Enables splitting payments into multiple installments.\n * Buyer pays first installment and gets access, then pays remaining\n * installments on schedule. Access is paused if payments are missed.\n */\n\nimport type {\n  Storage,\n  InstallmentPlan,\n  InstallmentPayment,\n  InstallmentConfig,\n  InstallmentStatus,\n  CreateInstallmentPlanInput,\n  PayLink,\n  Payment,\n} from './types.js';\nimport { generateUUID } from './utils.js';\n\n/**\n * Default installment configuration\n */\nexport const DEFAULT_INSTALLMENT_CONFIG: InstallmentConfig = {\n  enabled: true,\n  totalInstallments: 4,\n  intervalDays: 30,\n  downPaymentPercent: 25,\n  gracePeriodDays: 3,\n  autoSuspend: true,\n};\n\n/**\n * Calculate installment amounts\n * @param totalAmount Total price amount\n * @param totalInstallments Number of installments\n * @param downPaymentPercent Percentage for first payment (0-100)\n * @returns Array of amounts for each installment\n */\nexport function calculateInstallmentAmounts(\n  totalAmount: string,\n  totalInstallments: number,\n  downPaymentPercent: number = 25\n): string[] {\n  const total = parseFloat(totalAmount);\n  if (isNaN(total) || total <= 0) {\n    throw new Error('Invalid total amount');\n  }\n  if (totalInstallments < 2) {\n    throw new Error('Minimum 2 installments required');\n  }\n  if (downPaymentPercent < 0 || downPaymentPercent > 100) {\n    throw new Error('Down payment percent must be between 0 and 100');\n  }\n\n  const amounts: string[] = [];\n\n  // Calculate down payment (first installment)\n  const downPayment = total * (downPaymentPercent / 100);\n  amounts.push(downPayment.toFixed(8));\n\n  // Calculate remaining installments\n  const remaining = total - downPayment;\n  const regularAmount = remaining / (totalInstallments - 1);\n\n  for (let i = 1; i < totalInstallments; i++) {\n    amounts.push(regularAmount.toFixed(8));\n  }\n\n  return amounts;\n}\n\n/**\n * Calculate next due date based on interval\n */\nexport function calculateNextDueDate(\n  fromDate: Date,\n  intervalDays: number\n): Date {\n  const next = new Date(fromDate);\n  next.setDate(next.getDate() + intervalDays);\n  return next;\n}\n\n/**\n * Calculate all due dates for an installment plan\n */\nexport function calculateDueDates(\n  startDate: Date,\n  totalInstallments: number,\n  intervalDays: number\n): Date[] {\n  const dates: Date[] = [startDate]; // First payment is immediate\n\n  for (let i = 1; i < totalInstallments; i++) {\n    const dueDate = new Date(startDate);\n    dueDate.setDate(dueDate.getDate() + intervalDays * i);\n    dates.push(dueDate);\n  }\n\n  return dates;\n}\n\n/**\n * Check if an installment payment is overdue\n */\nexport function isInstallmentOverdue(\n  dueDate: Date,\n  gracePeriodDays: number = 3\n): boolean {\n  const now = new Date();\n  const graceEnd = new Date(dueDate);\n  graceEnd.setDate(graceEnd.getDate() + gracePeriodDays);\n  return now > graceEnd;\n}\n\n/**\n * Check if a date is within grace period\n */\nexport function isInGracePeriod(\n  dueDate: Date,\n  gracePeriodDays: number = 3\n): boolean {\n  const now = new Date();\n  const graceEnd = new Date(dueDate);\n  graceEnd.setDate(graceEnd.getDate() + gracePeriodDays);\n  return now > dueDate && now <= graceEnd;\n}\n\n/**\n * Get installment plan progress info\n */\nexport function getInstallmentProgress(plan: InstallmentPlan): {\n  paidCount: number;\n  remainingCount: number;\n  paidAmount: string;\n  remainingAmount: string;\n  percentComplete: number;\n  isComplete: boolean;\n} {\n  const paidAmount = parseFloat(plan.paidAmount);\n  const totalAmount = parseFloat(plan.totalAmount);\n  const remainingAmount = totalAmount - paidAmount;\n\n  return {\n    paidCount: plan.completedInstallments,\n    remainingCount: plan.totalInstallments - plan.completedInstallments,\n    paidAmount: plan.paidAmount,\n    remainingAmount: remainingAmount.toFixed(8),\n    percentComplete: Math.round((paidAmount / totalAmount) * 100),\n    isComplete: plan.completedInstallments >= plan.totalInstallments,\n  };\n}\n\n/**\n * Format installment schedule for display\n */\nexport function formatInstallmentSchedule(\n  plan: InstallmentPlan,\n  payments: InstallmentPayment[]\n): Array<{\n  number: number;\n  amount: string;\n  dueDate: string;\n  status: 'paid' | 'current' | 'upcoming' | 'overdue';\n  paidAt?: string;\n  txHash?: string;\n}> {\n  const schedule: Array<{\n    number: number;\n    amount: string;\n    dueDate: string;\n    status: 'paid' | 'current' | 'upcoming' | 'overdue';\n    paidAt?: string;\n    txHash?: string;\n  }> = [];\n\n  const dueDates = calculateDueDates(\n    plan.createdAt,\n    plan.totalInstallments,\n    plan.intervalDays\n  );\n\n  for (let i = 0; i < plan.totalInstallments; i++) {\n    const payment = payments.find(p => p.installmentNumber === i + 1);\n    const dueDate = dueDates[i];\n    const now = new Date();\n\n    let status: 'paid' | 'current' | 'upcoming' | 'overdue';\n\n    if (payment?.status === 'confirmed') {\n      status = 'paid';\n    } else if (i < plan.completedInstallments) {\n      status = 'paid';\n    } else if (i === plan.completedInstallments) {\n      // Current installment\n      if (isInstallmentOverdue(dueDate, plan.gracePeriodDays)) {\n        status = 'overdue';\n      } else {\n        status = 'current';\n      }\n    } else {\n      status = 'upcoming';\n    }\n\n    schedule.push({\n      number: i + 1,\n      amount: plan.installmentAmounts[i] || '0',\n      dueDate: dueDate.toISOString(),\n      status,\n      paidAt: payment?.confirmedAt?.toISOString(),\n      txHash: payment?.txHash,\n    });\n  }\n\n  return schedule;\n}\n\n/**\n * Installment Plan Manager\n */\nexport class InstallmentManager {\n  constructor(private storage: Storage) {}\n\n  /**\n   * Create a new installment plan\n   */\n  async createPlan(input: CreateInstallmentPlanInput): Promise<InstallmentPlan> {\n    const payLink = await this.storage.getPayLink(input.payLinkId);\n    if (!payLink) {\n      throw new Error('PayLink not found');\n    }\n\n    if (!payLink.installment?.enabled) {\n      throw new Error('Installments not enabled for this link');\n    }\n\n    // Check if buyer already has a plan for this link\n    const existing = await this.storage.getInstallmentPlanByAddress(\n      input.payLinkId,\n      input.buyerAddress\n    );\n    if (existing && existing.status !== 'completed' && existing.status !== 'cancelled') {\n      throw new Error('Active installment plan already exists for this buyer');\n    }\n\n    const config = payLink.installment;\n    const totalAmount = payLink.price.amount;\n    const totalInstallments = config.totalInstallments || 4;\n    const downPaymentPercent = config.downPaymentPercent ?? 25;\n    const intervalDays = config.intervalDays || 30;\n    const gracePeriodDays = config.gracePeriodDays ?? 3;\n\n    // Calculate installment amounts\n    const installmentAmounts = calculateInstallmentAmounts(\n      totalAmount,\n      totalInstallments,\n      downPaymentPercent\n    );\n\n    const now = new Date();\n    const firstDueDate = now; // First payment is immediate\n\n    const plan: InstallmentPlan = {\n      id: generateUUID(),\n      payLinkId: input.payLinkId,\n      buyerAddress: input.buyerAddress,\n      status: 'pending',\n      totalAmount,\n      paidAmount: '0',\n      totalInstallments,\n      completedInstallments: 0,\n      installmentAmounts,\n      intervalDays,\n      gracePeriodDays,\n      nextDueDate: firstDueDate,\n      nextInstallmentNumber: 1,\n      createdAt: now,\n      updatedAt: now,\n      metadata: input.metadata,\n    };\n\n    await this.storage.saveInstallmentPlan(plan);\n\n    return plan;\n  }\n\n  /**\n   * Get installment plan by ID\n   */\n  async getPlan(id: string): Promise<InstallmentPlan | null> {\n    return this.storage.getInstallmentPlan(id);\n  }\n\n  /**\n   * Get plan by buyer address\n   */\n  async getPlanByAddress(\n    payLinkId: string,\n    buyerAddress: string\n  ): Promise<InstallmentPlan | null> {\n    return this.storage.getInstallmentPlanByAddress(payLinkId, buyerAddress);\n  }\n\n  /**\n   * Process an installment payment\n   */\n  async processPayment(\n    planId: string,\n    payment: Payment\n  ): Promise<InstallmentPayment> {\n    const plan = await this.storage.getInstallmentPlan(planId);\n    if (!plan) {\n      throw new Error('Installment plan not found');\n    }\n\n    if (plan.status === 'completed') {\n      throw new Error('Installment plan already completed');\n    }\n\n    if (plan.status === 'cancelled') {\n      throw new Error('Installment plan was cancelled');\n    }\n\n    const installmentNumber = plan.nextInstallmentNumber;\n    const expectedAmount = plan.installmentAmounts[installmentNumber - 1];\n\n    // Create installment payment record\n    const installmentPayment: InstallmentPayment = {\n      id: generateUUID(),\n      installmentPlanId: planId,\n      paymentId: payment.id,\n      payLinkId: plan.payLinkId,\n      buyerAddress: plan.buyerAddress,\n      installmentNumber,\n      amount: payment.amount,\n      expectedAmount,\n      txHash: payment.txHash,\n      chainId: payment.chainId,\n      tokenSymbol: payment.tokenSymbol || 'SOL',\n      status: 'pending',\n      dueDate: plan.nextDueDate,\n      createdAt: new Date(),\n    };\n\n    await this.storage.saveInstallmentPayment(installmentPayment);\n\n    return installmentPayment;\n  }\n\n  /**\n   * Confirm an installment payment\n   */\n  async confirmPayment(installmentPaymentId: string): Promise<{\n    payment: InstallmentPayment;\n    plan: InstallmentPlan;\n  }> {\n    const payment = await this.storage.getInstallmentPayment(installmentPaymentId);\n    if (!payment) {\n      throw new Error('Installment payment not found');\n    }\n\n    const plan = await this.storage.getInstallmentPlan(payment.installmentPlanId);\n    if (!plan) {\n      throw new Error('Installment plan not found');\n    }\n\n    // Update payment status\n    payment.status = 'confirmed';\n    payment.confirmedAt = new Date();\n    await this.storage.updateInstallmentPayment(payment);\n\n    // Update plan\n    const paidAmount = parseFloat(plan.paidAmount) + parseFloat(payment.amount);\n    plan.paidAmount = paidAmount.toFixed(8);\n    plan.completedInstallments++;\n    plan.updatedAt = new Date();\n\n    // Check if first payment - activate access\n    if (plan.completedInstallments === 1 && plan.status === 'pending') {\n      plan.status = 'active';\n      plan.activatedAt = new Date();\n    }\n\n    // Check if all installments completed\n    if (plan.completedInstallments >= plan.totalInstallments) {\n      plan.status = 'completed';\n      plan.completedAt = new Date();\n    } else {\n      // Calculate next due date\n      plan.nextInstallmentNumber++;\n      plan.nextDueDate = calculateNextDueDate(\n        plan.nextDueDate,\n        plan.intervalDays\n      );\n      \n      // If was suspended, reactivate\n      if (plan.status === 'suspended') {\n        plan.status = 'active';\n        plan.suspendedAt = undefined;\n      }\n    }\n\n    await this.storage.updateInstallmentPlan(plan);\n\n    return { payment, plan };\n  }\n\n  /**\n   * Suspend a plan due to missed payment\n   */\n  async suspendPlan(planId: string, reason?: string): Promise<InstallmentPlan> {\n    const plan = await this.storage.getInstallmentPlan(planId);\n    if (!plan) {\n      throw new Error('Installment plan not found');\n    }\n\n    if (plan.status !== 'active') {\n      throw new Error('Can only suspend active plans');\n    }\n\n    plan.status = 'suspended';\n    plan.suspendedAt = new Date();\n    plan.updatedAt = new Date();\n    if (reason) {\n      plan.metadata = { ...plan.metadata, suspendReason: reason };\n    }\n\n    await this.storage.updateInstallmentPlan(plan);\n\n    return plan;\n  }\n\n  /**\n   * Cancel an installment plan\n   */\n  async cancelPlan(planId: string, reason?: string): Promise<InstallmentPlan> {\n    const plan = await this.storage.getInstallmentPlan(planId);\n    if (!plan) {\n      throw new Error('Installment plan not found');\n    }\n\n    if (plan.status === 'completed') {\n      throw new Error('Cannot cancel completed plan');\n    }\n\n    plan.status = 'cancelled';\n    plan.cancelledAt = new Date();\n    plan.updatedAt = new Date();\n    if (reason) {\n      plan.metadata = { ...plan.metadata, cancelReason: reason };\n    }\n\n    await this.storage.updateInstallmentPlan(plan);\n\n    return plan;\n  }\n\n  /**\n   * Get all payments for a plan\n   */\n  async getPlanPayments(planId: string): Promise<InstallmentPayment[]> {\n    return this.storage.getInstallmentPaymentsByPlan(planId);\n  }\n\n  /**\n   * Get overdue plans\n   */\n  async getOverduePlans(): Promise<InstallmentPlan[]> {\n    return this.storage.getOverdueInstallmentPlans();\n  }\n\n  /**\n   * Get plans due soon (within N days)\n   */\n  async getPlansDueSoon(withinDays: number = 3): Promise<InstallmentPlan[]> {\n    const cutoff = new Date();\n    cutoff.setDate(cutoff.getDate() + withinDays);\n    return this.storage.getInstallmentPlansDueBefore(cutoff);\n  }\n\n  /**\n   * Check and suspend overdue plans\n   */\n  async processOverduePlans(): Promise<InstallmentPlan[]> {\n    const overdue = await this.getOverduePlans();\n    const suspended: InstallmentPlan[] = [];\n\n    for (const plan of overdue) {\n      if (plan.status === 'active') {\n        const updated = await this.suspendPlan(plan.id, 'Payment overdue');\n        suspended.push(updated);\n      }\n    }\n\n    return suspended;\n  }\n\n  /**\n   * Get installment plan details with schedule\n   */\n  async getPlanDetails(planId: string): Promise<{\n    plan: InstallmentPlan;\n    payments: InstallmentPayment[];\n    schedule: ReturnType<typeof formatInstallmentSchedule>;\n    progress: ReturnType<typeof getInstallmentProgress>;\n  } | null> {\n    const plan = await this.storage.getInstallmentPlan(planId);\n    if (!plan) {\n      return null;\n    }\n\n    const payments = await this.storage.getInstallmentPaymentsByPlan(planId);\n    const schedule = formatInstallmentSchedule(plan, payments);\n    const progress = getInstallmentProgress(plan);\n\n    return {\n      plan,\n      payments,\n      schedule,\n      progress,\n    };\n  }\n\n  /**\n   * Check if buyer has active access\n   */\n  async hasActiveAccess(\n    payLinkId: string,\n    buyerAddress: string\n  ): Promise<boolean> {\n    const plan = await this.storage.getInstallmentPlanByAddress(\n      payLinkId,\n      buyerAddress\n    );\n\n    if (!plan) {\n      return false;\n    }\n\n    // Active or completed plans have access\n    return plan.status === 'active' || plan.status === 'completed';\n  }\n}\n\n/**\n * Create an installment manager instance\n */\nexport function createInstallmentManager(storage: Storage): InstallmentManager {\n  return new InstallmentManager(storage);\n}\n","/**\n * PAYLINK Token Integration\n * Native token support for Paylink Protocol\n * \n * Token: PAYLINK\n * Mint: cMNjNj2NMaEniE37KvyV2GCyQJnbY8YDeANBhSMpump\n * Chain: Solana\n * Decimals: 6 (standard pump.fun token)\n */\n\nimport type { PaymentCheckResult } from './types.js';\n\n/**\n * PAYLINK Token Constants\n */\nexport const PAYLINK_TOKEN = {\n  /** Token mint address */\n  MINT: 'cMNjNj2NMaEniE37KvyV2GCyQJnbY8YDeANBhSMpump',\n  /** Token symbol */\n  SYMBOL: 'PAYLINK',\n  /** Token decimals (pump.fun standard) */\n  DECIMALS: 6,\n  /** Chain ID (Solana mainnet) */\n  CHAIN_ID: 101,\n} as const;\n\n/**\n * Discount tiers based on PAYLINK holdings\n */\nexport interface DiscountTier {\n  /** Minimum token balance required */\n  minBalance: number;\n  /** Discount percentage (0-100) */\n  discountPercent: number;\n  /** Tier name */\n  name: string;\n}\n\n/**\n * Default discount tiers\n */\nexport const DEFAULT_DISCOUNT_TIERS: DiscountTier[] = [\n  { minBalance: 1_000_000, discountPercent: 50, name: 'Diamond' },    // 1M tokens = 50% off\n  { minBalance: 500_000, discountPercent: 30, name: 'Platinum' },     // 500K tokens = 30% off\n  { minBalance: 100_000, discountPercent: 20, name: 'Gold' },         // 100K tokens = 20% off\n  { minBalance: 10_000, discountPercent: 10, name: 'Silver' },        // 10K tokens = 10% off\n  { minBalance: 1_000, discountPercent: 5, name: 'Bronze' },          // 1K tokens = 5% off\n];\n\n/**\n * PAYLINK configuration\n */\nexport interface PaylinkTokenConfig {\n  /** Solana RPC URL */\n  rpcUrl: string;\n  /** Enable PAYLINK token payments */\n  enableTokenPayments?: boolean;\n  /** Discount when paying with PAYLINK (percentage, 0-100) */\n  tokenPaymentDiscount?: number;\n  /** Enable holder discounts */\n  enableHolderDiscounts?: boolean;\n  /** Custom discount tiers (optional) */\n  discountTiers?: DiscountTier[];\n  /** Request timeout in ms */\n  timeout?: number;\n}\n\ninterface TokenAccountInfo {\n  mint: string;\n  owner: string;\n  amount: string;\n  decimals: number;\n}\n\ninterface JsonRpcResponse<T> {\n  jsonrpc: string;\n  id: number;\n  result?: T;\n  error?: { code: number; message: string };\n}\n\n/**\n * PAYLINK Token Manager\n * Handles token balance checks, discounts, and SPL token payment verification\n */\nexport class PaylinkTokenManager {\n  private config: Required<PaylinkTokenConfig>;\n  private requestId = 0;\n\n  constructor(config: PaylinkTokenConfig) {\n    this.config = {\n      rpcUrl: config.rpcUrl,\n      enableTokenPayments: config.enableTokenPayments ?? true,\n      tokenPaymentDiscount: config.tokenPaymentDiscount ?? 10,\n      enableHolderDiscounts: config.enableHolderDiscounts ?? true,\n      discountTiers: config.discountTiers ?? DEFAULT_DISCOUNT_TIERS,\n      timeout: config.timeout ?? 30000,\n    };\n  }\n\n  /**\n   * Get PAYLINK token balance for a wallet\n   */\n  async getTokenBalance(walletAddress: string): Promise<number> {\n    try {\n      const tokenAccounts = await this.getTokenAccountsByOwner(walletAddress);\n      \n      const paylinkAccount = tokenAccounts.find(\n        acc => acc.mint === PAYLINK_TOKEN.MINT\n      );\n\n      if (!paylinkAccount) {\n        return 0;\n      }\n\n      // Convert from raw amount to token amount\n      return Number(paylinkAccount.amount) / Math.pow(10, PAYLINK_TOKEN.DECIMALS);\n    } catch (error) {\n      console.error('Error fetching PAYLINK balance:', error);\n      return 0;\n    }\n  }\n\n  /**\n   * Get discount tier for a wallet based on PAYLINK holdings\n   */\n  async getDiscountTier(walletAddress: string): Promise<DiscountTier | null> {\n    if (!this.config.enableHolderDiscounts) {\n      return null;\n    }\n\n    const balance = await this.getTokenBalance(walletAddress);\n    \n    // Sort tiers by minBalance descending to find highest qualifying tier\n    const sortedTiers = [...this.config.discountTiers].sort(\n      (a, b) => b.minBalance - a.minBalance\n    );\n\n    for (const tier of sortedTiers) {\n      if (balance >= tier.minBalance) {\n        return tier;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Calculate discounted price based on holder tier\n   */\n  async calculateDiscountedPrice(\n    walletAddress: string,\n    originalPrice: number\n  ): Promise<{ price: number; discount: number; tier: DiscountTier | null }> {\n    const tier = await this.getDiscountTier(walletAddress);\n    \n    if (!tier) {\n      return { price: originalPrice, discount: 0, tier: null };\n    }\n\n    const discount = (originalPrice * tier.discountPercent) / 100;\n    const price = originalPrice - discount;\n\n    return { price, discount, tier };\n  }\n\n  /**\n   * Get price when paying with PAYLINK token\n   */\n  getTokenPaymentPrice(originalPrice: number): number {\n    if (!this.config.enableTokenPayments) {\n      return originalPrice;\n    }\n\n    const discount = (originalPrice * this.config.tokenPaymentDiscount) / 100;\n    return originalPrice - discount;\n  }\n\n  /**\n   * Verify PAYLINK token payment\n   */\n  async verifyTokenPayment(params: {\n    txHash: string;\n    recipient: string;\n    amount: string;\n  }): Promise<PaymentCheckResult> {\n    try {\n      const tx = await this.getTransaction(params.txHash);\n\n      if (!tx) {\n        return { status: 'not_found' };\n      }\n\n      if (tx.meta?.err) {\n        return { status: 'failed' };\n      }\n\n      // Parse SPL token transfer\n      const transfer = this.parseTokenTransfer(tx, params.recipient);\n\n      if (!transfer) {\n        return { status: 'not_found' };\n      }\n\n      // Verify it's PAYLINK token\n      if (transfer.mint !== PAYLINK_TOKEN.MINT) {\n        return { status: 'not_found' };\n      }\n\n      // Convert amount to token units\n      const actualAmount = transfer.amount / Math.pow(10, PAYLINK_TOKEN.DECIMALS);\n      const requiredAmount = parseFloat(params.amount);\n\n      if (actualAmount < requiredAmount) {\n        return {\n          status: 'underpaid',\n          actualAmount: actualAmount.toString(),\n          fromAddress: transfer.from,\n        };\n      }\n\n      return {\n        status: 'confirmed',\n        actualAmount: actualAmount.toString(),\n        fromAddress: transfer.from,\n        raw: tx,\n      };\n    } catch (error) {\n      console.error('PAYLINK payment verification error:', error);\n      return { status: 'not_found' };\n    }\n  }\n\n  /**\n   * Parse SPL token transfer from transaction\n   */\n  private parseTokenTransfer(\n    tx: any,\n    expectedRecipient: string\n  ): { mint: string; from: string; to: string; amount: number } | null {\n    try {\n      // Look for token balance changes in postTokenBalances\n      const preBalances = tx.meta?.preTokenBalances || [];\n      const postBalances = tx.meta?.postTokenBalances || [];\n\n      // Find PAYLINK transfers to recipient\n      for (const post of postBalances) {\n        if (post.mint !== PAYLINK_TOKEN.MINT) continue;\n\n        const pre = preBalances.find(\n          (p: any) => p.accountIndex === post.accountIndex\n        );\n\n        const preAmount = pre ? Number(pre.uiTokenAmount?.amount || 0) : 0;\n        const postAmount = Number(post.uiTokenAmount?.amount || 0);\n        const diff = postAmount - preAmount;\n\n        if (diff > 0) {\n          // This account received tokens\n          const owner = post.owner;\n          \n          if (owner?.toLowerCase() === expectedRecipient.toLowerCase()) {\n            // Find sender (account with negative diff)\n            let sender = '';\n            for (const otherPost of postBalances) {\n              if (otherPost.mint !== PAYLINK_TOKEN.MINT) continue;\n              const otherPre = preBalances.find(\n                (p: any) => p.accountIndex === otherPost.accountIndex\n              );\n              const otherPreAmount = otherPre ? Number(otherPre.uiTokenAmount?.amount || 0) : 0;\n              const otherPostAmount = Number(otherPost.uiTokenAmount?.amount || 0);\n              if (otherPostAmount - otherPreAmount < 0) {\n                sender = otherPost.owner || '';\n                break;\n              }\n            }\n\n            return {\n              mint: PAYLINK_TOKEN.MINT,\n              from: sender,\n              to: owner,\n              amount: diff,\n            };\n          }\n        }\n      }\n\n      return null;\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Get token accounts for a wallet\n   */\n  private async getTokenAccountsByOwner(owner: string): Promise<TokenAccountInfo[]> {\n    const result = await this.rpc<{\n      value: Array<{\n        account: {\n          data: {\n            parsed: {\n              info: TokenAccountInfo;\n            };\n          };\n        };\n      }>;\n    }>('getTokenAccountsByOwner', [\n      owner,\n      { programId: 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' },\n      { encoding: 'jsonParsed' },\n    ]);\n\n    if (!result?.value) {\n      return [];\n    }\n\n    return result.value.map(item => item.account.data.parsed.info);\n  }\n\n  /**\n   * Get transaction details\n   */\n  private async getTransaction(signature: string): Promise<any> {\n    return this.rpc('getTransaction', [\n      signature,\n      {\n        encoding: 'jsonParsed',\n        commitment: 'confirmed',\n        maxSupportedTransactionVersion: 0,\n      },\n    ]);\n  }\n\n  /**\n   * Make RPC call\n   */\n  private async rpc<T>(method: string, params: unknown[]): Promise<T | null> {\n    const controller = new AbortController();\n    const timeout = setTimeout(() => controller.abort(), this.config.timeout);\n\n    try {\n      const response = await fetch(this.config.rpcUrl, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          jsonrpc: '2.0',\n          id: ++this.requestId,\n          method,\n          params,\n        }),\n        signal: controller.signal,\n      });\n\n      const data = (await response.json()) as JsonRpcResponse<T>;\n\n      if (data.error) {\n        console.error('RPC error:', data.error);\n        return null;\n      }\n\n      return data.result ?? null;\n    } catch (error) {\n      console.error('RPC request failed:', error);\n      return null;\n    } finally {\n      clearTimeout(timeout);\n    }\n  }\n}\n\n/**\n * Create a PAYLINK token manager\n */\nexport function createPaylinkTokenManager(config: PaylinkTokenConfig): PaylinkTokenManager {\n  return new PaylinkTokenManager(config);\n}\n\n/**\n * Check if a token symbol is PAYLINK\n */\nexport function isPaylinkToken(symbol: string): boolean {\n  return symbol.toUpperCase() === PAYLINK_TOKEN.SYMBOL;\n}\n\n/**\n * Format PAYLINK amount for display\n */\nexport function formatPaylinkAmount(amount: number): string {\n  if (amount >= 1_000_000) {\n    return `${(amount / 1_000_000).toFixed(2)}M`;\n  }\n  if (amount >= 1_000) {\n    return `${(amount / 1_000).toFixed(2)}K`;\n  }\n  return amount.toFixed(2);\n}\n"],"mappings":"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","names":["ReasonCode","createHmac","payment"]}